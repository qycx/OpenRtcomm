using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Threading;
using qy;

partial class Consts
{
	public const int CONST_misMsgType_null = 0;
	public const int CONST_misMsgType_base = CONST_qyWmParam_misMsg_base;
	public const int CONST_misMsgType_resp_onlySock = (CONST_misMsgType_base + 1);  //  
	public const int CONST_misMsgType_quit = (CONST_misMsgType_base + 2);
	public const int CONST_misMsgType_closeSession = (CONST_misMsgType_base + 3);
	public const int CONST_misMsgType_input = (CONST_misMsgType_base + 4);
	public const int CONST_misMsgType_send = (CONST_misMsgType_base + 5);   //  
	public const int CONST_misMsgType_processSelf = (CONST_misMsgType_base + 6);    //  
	public const int CONST_misMsgType_processBt = (CONST_misMsgType_base + 7);  //  2011/04/18
																				//public const int		CONST_misMsgType_processSelf_sendFinished			(  CONST_misMsgType_base  +  8	)	//  2015/08/18
	public const int CONST_misMsgType_processSelf_new = (CONST_misMsgType_base + 9);    //  2015/08/21
	public const int CONST_misMsgType_inputArrive = (CONST_misMsgType_base + 10);   //  2015/08/24
																					//public const int		CONST_misMsgType_resp1								(  CONST_misMsgType_base  +  11	 )	//  2015/08/25. 暂时用来替换resp,以帮助发现未加密的resp
	public const int CONST_misMsgType_resp2 = (CONST_misMsgType_base + 12); //  2015/08/25. resp的处理标识已经是网络字节流顺序，resp2表明不是网络顺序


	//  
	//  public const int		CONST_misMsgType_resumeToSend					(  CONST_misMsgType_base  +  16  )	//	
	//  
	public const int CONST_misMsgType_req = (CONST_misMsgType_base + 30);   //  messenger·
	public const int CONST_misMsgType_resp = (CONST_misMsgType_base + 31);  //  iocp·
	public const int CONST_misMsgType_talk = (CONST_misMsgType_base + 32);  //  
	public const int CONST_misMsgType_task = (CONST_misMsgType_base + 33);  //  
																			//
																			//
	public const int CONST_misMsgType_isSendOk = (CONST_misMsgType_base + 50);  //  iocp iocp tranNo. messenger outputQ iocp,tranNo starttime
	public const int CONST_misMsgType_sendOk = (CONST_misMsgType_base + 51);    //  MGR tranNo. messenger iocp, tranNoºÍstarttime
																				//  mgr·
																				//
	public const int CONST_misMsgType_sendFinished = (CONST_misMsgType_base + 52);  //  mgr
																					//
																					//  public const int		CONST_misMsgType_closeChannel					(  CONST_misMsgType_base  +  53  )	//  2007/12/20, QMemMessenge
	public const int CONST_misMsgType_closeChannelByCliIndex = (CONST_misMsgType_base + 53);    //  2007/12/20, 
	public const int CONST_misMsgType_chkChannelByType_mgr = (CONST_misMsgType_base + 54);  //  2015/08/26, 
																							//
	public const int CONST_misMsgType_applyForWork = (CONST_misMsgType_base + 55);  //  
																					//////
	public const int CONST_misMsgType_taskStatus = (CONST_misMsgType_base + 60);    //  
	public const int CONST_misMsgType_imMsgRcd = (CONST_misMsgType_base + 61);  //  
	public const int CONST_misMsgType_event = (CONST_misMsgType_base + 62); //  

	//  ÒÔÉÏÊÇ°üÀàÐÍ
	public const int CONST_misMsgType_talkingFriend_qmc = (CONST_misMsgType_base + 70); //	talkingFriendQ
	public const int CONST_misMsgType_recentFriend_qmc = (CONST_misMsgType_base + 71);  //	recentFriendQ
	public const int CONST_misMsgType_displayedElem_qmc = (CONST_misMsgType_base + 72); //  
	public const int CONST_misMsgType_refreshContactsStatus_qmc = (CONST_misMsgType_base + 73); //  messenger display
	public const int CONST_misMsgType_refreshMeStatus_qmc = (CONST_misMsgType_base + 74);   //  diplay
	public const int CONST_misMsgType_applyForPlayer_qmc = (CONST_misMsgType_base + 75);    //  
	public const int CONST_misMsgType_applyForChkChannels_qmc = (CONST_misMsgType_base + 76);   //  
	public const int CONST_misMsgType_applyForRemovingInvalidTasks_qmc = (CONST_misMsgType_base + 77);  //  2009/09/10
	public const int CONST_misMsgType_applyForTalkerShadow_qmc = (CONST_misMsgType_base + 78);  //  2012/04/23. 由墙发起,请求dlgTalk生成一个影子窗口

	//
	public const int CONST_misMsgType_procVideo_qmc = (CONST_misMsgType_base + 80); //  2009/03/24
	public const int CONST_misMsgType_notifyTaskEnd_qmc = (CONST_misMsgType_base + 81); //  2009/04/28
	public const int CONST_misMsgType_procGps_qmc = (CONST_misMsgType_base + 82);   //  2012/04/20
																					//
	public const int CONST_misMsgType_getDaemonStatus = (CONST_misMsgType_base + 85);   //  2011/01/12
																						//
	public const int CONST_misMsgType_outputTask = (CONST_misMsgType_base + 90);    //  robot
	public const int CONST_misMsgType_outputTask_toMix = (CONST_misMsgType_base + 91);  //  2011/01/23


	//  2008/05/26
	public const int CONST_misMsgType_grp = (CONST_misMsgType_base + 200);	//  ×éºÏ°ü¡£×éºÏ°üÓÐÊ±ºÜ´ó.²»Òª½«MIS_MSGUºÍ×éºÏ°ü»ìÆðÀ´¡£·ñÔò£¬Ó°ÏìÍ¨³£µÄMIS_MSGUµÄÄÚ´æ·ÖÅä¡£

	public const int CONST_maxContactUpdateInfos_grp = 128;                                         //  2014/02/06
	public const int CONST_maxContactUpdateInfos_grpMem = 2048;                                     //  2014/02/06
	public const int CONST_maxContactUpdateInfos_contact = 128 * 3;                                 //  2014/02/09

	public const int CONST_maxMessengerNameLen = 255;
	public const int CONST_maxMessengerPasswdLen = 255;

	public const int CONST_maxMisServNameLen = 32;                  //  2010/08/05

	//
	public const int CONST_qyMessengerIdStrLen = 18;                    //  
																		//
	public const Int64 CONST_invalidMessengerId = -1;                   //  2007/07/28 

	public const int CONST_cntof_wRndName_serv=255+1;
	public const int CONST_cntof_talkerDesc = 32;
	public const int CONST_cntof_clientWelcomMsg=128;
	public const int CONST_cntof_hint=255+1;

	//
	public const int CONST_maxMsgrs_sendTo = 32;                    //  

	

	//
	public const int CONST_bufSize_imDataContent = 63 * 1024;
	public const int CONST_bufSize_imStreamContent = 63 * 1024;                     //  2008/03/22, 
	public const int CONST_bufSize_imLStream = (900 + 32) * 1024;       //  2008/03/22, 这个包应该比别的包略大一点，所以+32


	//
	public const int CONST_bufSize_talkData = CONST_bufSize_imLStream + 2 * 1024;//pc 2443304;
	public const int CONST_bufSize_routeTalkData = CONST_bufSize_imLStream + 2 * 1024;


	//
	//  public const int 		CONST_bufSize_transferFileDataResp				32  *  1024
	//  public const int 		CONST_bufSize_transferFileDataResp				64  *  1024						//  2010/12/05
	public const int CONST_bufSize_transferFileDataResp = 128 * 1024;                   //  2014/07/13
																						//
	public const int CONST_bufSize_transferVideoData = 900 * 1024;                  //  2012/06/28. mediaSdk压缩出来的一个包就可能600k.cuda压缩出来的一个包可能700多k
	public const int CONST_bufSize_transferAudioData = 512 * 1024;                  //  2009/05/20

	//  public const int 		CONST_bufSize_myDrawVideoData					8  *  1024  *  1024				//  2009/05/03
	public const int CONST_bufSize_myDrawVideoData_2k = 8 * 1024 * 1024;                //  2009/05/03
	public const int CONST_bufSize_myDrawVideoData_4k = 36 * 1024 * 1024;           //  2014/06/01. 4096X2304, 3840X2160

	public const int CONST_bufSize_myPlayAudioData = 1 * 1024 * 1024;

	//
	public const int cntof_imHtmlContent_wBuf = 16 * 1024;

	//
	public const int CONST_maxContactUpdateInfos_025909 = 10;                                           // 

	//
	public const int CONST_sizeof_imGrpInfo = 248;
	//IM_GRP_INFO mems[Consts.CONST_maxContactUpdateInfos_grp];          //  ·Ç½áÊø°ü	
	public const int CONST_bufSize_imGrpInfo_mems	=	CONST_sizeof_imGrpInfo * Consts.CONST_maxContactUpdateInfos_grp;
	//
	public const int CONST_sizeof_imGrpMem = 128;
	//IM_GRP_MEM mems[CONST_maxContactUpdateInfos_grpMem];            //  ·Ç½áÊø°ü	
	public const int CONST_bufSize_imGrpMem_mems=CONST_sizeof_imGrpMem * Consts.CONST_maxContactUpdateInfos_grpMem;

	//
	public const int CONST_sizeof_retrieveContaceMem = 976;
	//RETRIEVE_contact_mem mems[CONST_maxContactUpdateInfos_contact];         //  ·Ç½áÊø°ü	
	public const int CONST_bufSize_retrieveContaceMem_mems=CONST_sizeof_retrieveContaceMem * CONST_maxContactUpdateInfos_contact;

	//
	public const int CONST_maxNameLen = 64;

	//
	public const int MAX_imObjRule_reqMems = 10;
	//
	public const int DEFAULT_maxImObjRule_reqMems = 10;                 //  当req.usMaxMemsPerSnd为0时，取此值. 不能修改. 2011/11/13


	//
	public const int CONST_sizeof_refreshImObjRuleReqMem = 280;
	//REFRESH_imObjRule_reqMem mems[MAX_imObjRule_reqMems];				 
	public const int CONST_bufSize_REFRESH_imObjRule_reqMem_mems=CONST_sizeof_refreshImObjRuleReqMem * MAX_imObjRule_reqMems;


	//
	//  2015/08/02
	public const int CONST_procOfflineResSubtype_null = 0;
	public const int CONST_procOfflineResSubtype_getCfgs = 1;
	public const int CONST_procOfflineResSubtype_retrieve = 2;
	public const int CONST_procOfflineResSubtype_upload = 3;
	public const int CONST_procOfflineResSubtype_download = 4;
	public const int CONST_procOfflineResSubtype_del = 5;


}


namespace qy
{
	public struct PLAYER_ID
	{
		int index_player;
		uint uiTranNo_player;
	}
	;
	public struct MSG_SIMPLE_ROUTE
	{                                       //  
		public QY_MESSENGER_ID idInfo_to;
		public QY_MESSENGER_ID idInfo_from;
	}
	 ;

	public struct MSG_DEBUG_INFO
	{
		Int64 tTime_serv_startToRecv;                 //  iocpÆðÊ¼ÊÕ°üÊ±¼ä( s )
		/*
		ushort usElapsed_serv_recved;                   //  ÊÕÍê
		ushort usElapsed_serv_startToProcess;           //  ¿ªÊ¼´¦Àí		
		ushort usElapsed_serv_toFindDst;                //  ÔÚÑ°ÕÒÄ¿±ê¶ÔÏóÖ®Ç°¡£
		ushort usElapsed_serv_toBeSwitched;         //  ·ÖÈë
		ushort usElapsed_serv_toSend;                   //  ×¼±¸·¢ËÍ
		*/
	}
	;


	public struct ROUTE_DEBUG_INFO
	{                                       //  ´Ë½á¹¹ÎªÁËÁË½âÊý¾Ý°üµÄ´«Êä¹ý³Ì¶øÉè¼Æ.Í¨³£,dwTickCnt...ÊÇ²»ÓÃ´«ÊäµÄ.

		
		// 发起端
		public uint dwTickCnt_me_start;                       //  clientÆðÊ¼·¢ËÍÇëÇó
															  //
		public Int64 tTime_start;                            //  ¿ªÊ¼·¢ËÍ
		public ushort usElapsed_toSend;                        //  ×¼±¸·¢ËÍ

		//  2008/11/19
		public int index;                                  //  uiDataBlockIndex

		//
		public uint dwTickCnt_serv_startToRecv;               //  iocp ( ms ). 

		//  2015/08/15
		public uint dwTickCnt_processQ;
		public uint dwTickCnt_processQ2Grp;
		//
		public uint dwTickCnt_postMsg2OutputQ_imGrp;
		//
		public uint dwTickCnt_doMisMgr_processSelf_imGrp;
		//
		public uint dwTickCnt_tmpHandler_talkToGrpMem_bt;
		public uint dwTickCnt_postMsg2OutputQ_messenger;

		//  server转发请求
		public MSG_DEBUG_INFO req;


		//  接受并响应端
		public uint dwTickCnt_peer_recved;
		public Int64 tTime_peer_recved;
		public ushort usElapsed_peer_resp_toSend;

		//  server转发响应
		public MSG_DEBUG_INFO resp;

		//  响应回到发起端
		public uint dwTickCnt_resp_recved;
		public ushort usElapsed_resp_end;

		//  2011/12/08
		//DEBUG_myDRAW_VIDEO_DATA debug_myDRAW_VIDEO_DATA;                //  2011/12/08

		//
		public uint uiStep_showInfo;                       //  ÎªÁË¸øshowInfoÌá¹©Çø·ÖÍ¬Ò»¸öÊ±¿Ì(ms)µÄÔç³ÙµÄ²ÎÊý
		
	}
	;



	public unsafe struct MSG_ROUTE
	{                               //  
		public QY_MESSENGER_ID idInfo_to;                      //  2007/11/30, TALKDATA_ADDR
		public QY_MESSENGER_ID idInfo_from;                    //	
															   //
		public uint uiDevType_to;                  //
												   //WCHAR wDevIdStr_to[128];                //	2008/01/04, 
		public uint uiDevType_from;                    //
													   //WCHAR wDevIdStr_from[128];          //  2008/01/04
													   //  
													   //  path mailto:qycx@qycx.com|sm:13001101101|http://www.qycx.com/			
													   //																					
													   //
													   //
		public fixed Int64 mems_to_idInfo_ui64Id[Consts.CONST_maxMsgrs_sendTo];

		//
		public uint uiMsgRouteId;                 //  2008/05/27, msgRoute

		//																					//  peer.
		//  uint									uiWebSessId;					//  webMessenger
		public uint uiLogonId;                     //  webMessenger
												   //
		public uint uiObjType_src;                    //  messengerType, 
													  //
		public ushort usLangId_from;                   //  
		public uint ulDetectedIp_from;
		//public fixed char displayName_from[64 + 1];
		//

		//  2008/05/15
		public ROUTE_DEBUG_INFO debugInfo;

		//  2009/09/12
		//struct                                             {
		public ushort tmpInternal_usCnt_mems_to;
	//}tmpInternal;

}		 ;

	public unsafe struct MSGR_ADDR
	{
		public QY_MESSENGER_ID idInfo;
		//
		public fixed char misServName[Consts.CONST_maxMisServNameLen + 1];
		//
		public uint uiDevType;                     //
												   //WCHAR wDevIdStr[128];                   //   2008/01/04,
												   //WCHAR wPath[510 + 1];               //  
												   //																					//  
												   //  uint									uiWebSessId;					//  webMessenger
		public uint uiLogonId;                     //  webMessenger
												   //
		public uint uiObjType;
		//
		public fixed char displayName[64 + 1];
		//
		//
		//  2008/02/12, MSGR_ADDR messenger
		//  
		public bool bInNoticeMode;                 //  2008/01/22, 
												   //				
												   //				
		public Int64 tStartTime_notice;               //  tStartTime_notice uiTranNo_notice
		public uint uiTranNo_notice;               //

		//  2012/04/20
		public uint uiTranNo_shadow;               //  用来标识辅助talker窗口,为0时为主窗口

		//  2013/07/31
		//int												iNo_debug;						//  用来标识talker类实例,用来debug用. 2013/07/31

	}
	;


public unsafe struct QY_COMM_AUTHINFO_MIS
	{

		public byte ucCmd;

		public int iAppType;                               //  2011/03/27
		public int iCustemId;
		public uint uiChannelType;                         //  2007/07/08

		public fixed byte ver[Consts.CONST_qyMaxVerLen + 1];            //  
																		//

		public ushort usLangId;
		public uint uiDevType;
		//
		public ushort usAuthType;                              //  2011/03/22
															   //

		//QWM_MACS_INFO macsInfo;
		public fixed byte ip[Consts.CONST_qyMaxIpLen + 1];
		//WCHAR pcName[128 + 1];
		//WCHAR domainName[128 + 1];
		//WCHAR osUsrName[128 + 1];
		//

		//
		public fixed char messengerName[Consts.CONST_maxMessengerNameLen + 1];               //  messenger
		public fixed byte messengerPasswd[Consts.CONST_maxMessengerPasswdLen + 1];
		//
		public fixed char wRndName_serv[255 + 1];               //  
		public uint uiRnd_cli;                             //  web 2007/11/22
														   //
														   //  uint								uiWebSessId;							//  web2007/11/22
		public uint uiLogonId;                             //  2011/02/02
														   //  


		// ----------------------------------------

		public uint uiBlobLen_sessionKey;                  //  »á»°ÃÜÔ¿
		public fixed byte sessionKeyBlob[Consts.CONST_bufSize_sessionKeyBlob];
								
	}
	;

	//  ÈÏÖ¤ÏìÓ¦
	public unsafe struct AUTH_RESP_MIS
	{
		public QY_MESSENGER_ID idInfo;
		//
		public fixed char wRndName_serv[Consts.CONST_cntof_wRndName_serv];               //  webMessenger
																//  uint								uiWebSessId;							//  webMessenger
																//
		public uint uiLogonId;                             //  
														   //
		public uint uiCommEncCtxType;                      //  
		public uint uiBlobLen_publicKey;
		public fixed byte publicKeyBlob[Consts.CONST_bufSize_publicKeyBlob];                   //  serverHello

		//
		public bool ucbDaemonDemo;                            //  2009/10/11
		public ushort usMaxVideoConferenceMems;                //  2009/11/05
		public byte ucDays_left;                          //  2010/03/22
														  //
		public ushort usAppAvLevel_daemon;                 //  2011/10/22
														   //
		public ushort usSubSystemId_daemon;                    //  2017/06/21

		//
		public fixed char talkerDesc[Consts.CONST_cntof_talkerDesc];                           //  2011/04/07
		
		public fixed char wBuf_hint[Consts.CONST_cntof_hint];

		//
		public fixed char clientWelcomeMsg[Consts.CONST_cntof_clientWelcomMsg];                    //  2016/08/10
	}
	;

	 public unsafe struct QY_imAm_RCD
	{
		int id;
		fixed char misServName[255 + 1];
		QY_MESSENGER_ID idInfo;
		fixed char messengerName[255 + 1];
		fixed sbyte messengerPasswd[255 + 1];
		int iPasswdType;
		fixed sbyte salt[Consts.CONTS_passwdSaltLen + 1];
		int iStatus;
		fixed sbyte startTime[14 + 1];
		fixed sbyte tLastModifiedTime[14 + 1];
	}
	;




	//  2014/09/04


	//  2016/07/23
	public struct RES_OBJ
	{
		//M_resObj_common
		//

public 				uint					uiObjType;					
	public	ushort usIndex_obj;				
public		ushort usHelp_subIndex;

	}
	;

//
public struct QIS_RES_OBJ
	{
		//
		QY_MESSENGER_ID idInfo;                     //  2016/07/24
		RES_OBJ resObj;
		//
	}
	
//
public unsafe struct QIS_dynBmp_info
	{
		//
		QIS_RES_OBJ qisResObj;                      //  2016/07/23
													//
		fixed char name[32];                     //  name used to mean device id or unique name for dynBmp
		fixed char cusName[32];                  //  cusName used to mean a friendly comment for dynBmp
											//
		ushort usW, usH;
		//
	}
	;



	public struct TRANSFER_AUDIO_dataMemHead
	{
		//unsigned  short									usIndex_ii;							//  2013/07/18. 将被逐渐弃用

		QY_MESSENGER_ID idInfo;                             //  会议时,发言人的id

		//
		uint uiTranNo_openAvDev;                    //  2013/08/04. 当会议参会人,断开会议,修改策略,重新参会时,需要有tn来标识不同的视频流,所以要加这个成员


		struct TRANSFER_AUDIO_dataMemHead_tmpInternal
		{
					 uint uiTranNo_org;                     //  Ô­Ê¼°üµÄ
		ulong dwTickCnt_videoConferenceRecved;  //  ÊÓÆµ»áÒé·þÎñÆ÷ÊÕµ½µÄÊ±¼ä¡£ÓÃÀ´µ÷ÊÔºÍÁË½âÒôÆµ´«ÊäÐÔÄÜ¡£
	};
		TRANSFER_AUDIO_dataMemHead_tmpInternal		tmpInternal;						//  ÁÙÊ±Ê¹ÓÃµÄ±äÁ¿£¬²»ÄÜÓÃÔÚÍ¨ÐÅÖÐ

				 uint uiSampleTimeInMs;                 //  2009/05/02
	uint ui_rtTimeLen;                      //  2009/05/27

	//  2015/09/10
	uint uiPts;                             //  2015/09/10

	//
	uint uiLen;
}
;


//
//  2011/01/26
public struct TRANSFER_videoData_stat
	{
		Int64 tLastTime_showFrameInfo_020534;     //  

		//
		Int64 tSelectTime;                        //  2008/12/05
		ushort usCnt_pkts;                          //  tSelectTime. 020534 tLastTime_showFrameInfo->tStartTime
		ushort usFps;                               //  

		//
		int iVal_dbg;                           //  2017/09/04

	}
	;




//
public struct TRANSFER_VIDEO_dataMemHead
	{
		//unsigned  short									usIndex_ii;							//  2013/07/18. 将被逐步弃用

		QY_MESSENGER_ID idInfo;                             //  2009/05/31
															//
		uint uiTranNo_openAvDev;                    //  2012/01/09

		//
		uint uiSampleTimeInMs;                  //  2009/05/02
														//uint									uiSampleTimeInMs_org;				//  2009/05/27

		//  2015/01/15
		uint uiPts;                             //  2015/01/15

		//  2016/12/26
		//uint										uiEventId_lastRecvd_unused;				//  2013/11/15, 表示从remoteAssist收到了事件的id

		//
		uint uiLen;                             //  ¶ÔÓ¦µÄÊý¾Ý³¤¶È

		//
		TRANSFER_videoData_stat stat;                               //  2017/09/05

		//
	}
	;


	public struct myDRAW_VIDEO_DATA_input
	{
		//
		bool bRtsp;                                    //  2015/03/14

		//
		ulong tStartTran;                              //  2011/08/30

	};

	public struct myDRAW_VIDEO_DATA_vpp
	{
		uint uiCnt_vpp0;
		//
	};

	public struct myDRAW_VIDEO_DATA_decInfo
	{
		int index_pMems_from;
		//  2016/12/27
		uint uiEventId_lastRecvd_unused;                    //  2008/11/22

		//  2014/09/04
		QIS_RES_OBJ dynBmp;                                 //  2014/10/12

		//
		bool ucbUnresizable;                            //  2015/10/23

	};

	public struct myDRAW_VIDEO_DATA
	{
		public uint uiType_unused;
		//
		//uint										uiTranNo_openAvDev_unused;				//  2014/11/26.tranNo.

		//
		public uint uiCapType;
		public int iIndex_capBmp;

		public myDRAW_VIDEO_DATA_input input;

		//  2015/05/07

		public myDRAW_VIDEO_DATA_vpp vpp;

		//  2016/12/27
		public uint uiEventId_lastRecvd_unused;

		//
		public IntPtr hWnd_task;
		public int iTaskId;
		public uint uiTaskType;                                //  2014/10/01

		//
		public QY_MESSENGER_ID idInfo_peer;

		//  2011/12/09
		public myDRAW_VIDEO_DATA_decInfo decInfo;                                //  

		//  2011/12/08
		//DEBUG_myDRAW_VIDEO_DATA debugInfo;

		//  
		public long lPktId_alloc;                          //  2014/03/26.一个不重的序号. 分配内存的标识

		//
		public TRANSFER_VIDEO_dataMemHead head;                                    //  head.len表示pBuf中的缓冲长度, head.len和bih.biSizeImage不一定相等
		public ushort usIndex_activeMems_from;             //  2013/07/18.

		//  2015/09/30
		public ushort usPktResType;                            //  2015/09/30

		//  2015/09/30
		//PKT_sharedTex_info pktSharedTexInfo;

		//  2011/12/06
		public uint uiSize_dec;                                //  pBuf中分为2个区，一个为未压缩数据区，大小为uiSize_dec. uiSize_dec应<=head.len
		public BITMAPINFOHEADER bih;                                   //  2011/12/04. 此bih表明了未压缩区中的图像格式, bih.sizeImage应该<=uiSize_dec
																	   //
		public uint uiOffset_enc;
		public uint uiLen_enc;                             //  另一个为压缩数据区，大小为head.len - uiSize_dec，包含一个包头uiOffset_enc，紧跟一个压缩数据. 真实大小为uiLen_enc
														   //
														   //  2014/02/24. 当bRtsp为true, p->uiLen_enc  =  offsetof(  TRANSFER_VIDEO_DATA,  buf  )  +  BufferLen;


		//  char											*	pBuf;								//  2009/12/07, len is in head
		public QY_MEMORY memory;									//  2010/04/23

				 //

}		 ;


	//////////////////////////////////////////////////////////////////////
	///
	public unsafe struct IM_GRP_INFO
	{
		public uint uiType;                                //  2011/01/29
														   //
		public int id;
		public fixed char misServName[Consts.CONST_maxMisServNameLen + 1];
		public QY_MESSENGER_ID idInfo;                             //  
																   //
		public fixed char name[Consts.CONST_maxNameLen + 1];                    //  
		public ushort usSubtype;                           //  2014/01/31
														   //
		public QY_MESSENGER_ID idInfo_creator;                     // 2017/07/26
																   //
		public Int64 startTime;
		public Int64 tLastModifiedTime;
		//
		/*
		struct                                             {                                    //  2011/01/29
					 HWND hWnd_status;
		//
	}
	tmpInternal;
		*/
}
;
	public unsafe struct IM_GRP_MEM
	{
		public uint uiType;
		public int id;
		public fixed char misServName[Consts.CONST_maxMisServNameLen + 1];
		public QY_MESSENGER_ID idInfo_grp;
		public QY_MESSENGER_ID idInfo_mem;
		public int iRole;
		public Int64 startTime;
		public Int64 tLastModifiedTime;
		public int iStatus;
	}
	;


	public unsafe struct QY_MESSENGER_PCINFO
	{
		int id;

		fixed char misServName[Consts.CONST_maxMisServNameLen + 1];
		QY_MESSENGER_ID idInfo;
		//
		//
		uint uiType;
		//
		int iPlatformId;
		//
		fixed char pcName[255 + 1];
		fixed char domainName[255 + 1];
		fixed char osUsrName[255 + 1];
		//
		Int64 tLastModifiedTime;

	}
	;

	public unsafe struct QY_MESSENGER_phoneInfo
	{

		int id;
		fixed char misServName[Consts.CONST_maxMisServNameLen + 1];
		uint uiDevType;
		//TCHAR wDevIdStr[128 + 1];
		//
		fixed char messengerPasswd[255 + 1];
		//
		QY_MESSENGER_ID idInfo;
		//
		int iStatus;
		//																				
		Int64 startTime;
		Int64 tLastModifiedTime;

	}
	;


public unsafe struct QY_MESSENGER_INFO
	{

		public uint uiType;                                        //  messengerType, me, messenger, group

		public int iRcdId;                                     //  qyMessengerTab id

		public fixed char misServName[Consts.CONST_maxMisServNameLen + 1];
		public QY_MESSENGER_ID idInfo;

		//
		public uint uiLogonId;                                 //  2007/12/22
		public Int64 tTime_logon;                             //  2022/02/02
		public fixed char wLocation[64 + 1];

		//
		public fixed byte  ip[Consts.CONST_qyMaxIpLen + 1];
		public fixed byte detectedIp[Consts.CONST_qyMaxIpLen + 1];

		public ushort usLangId;
		//
		public uint uiDevType;
		//
		public fixed char messengerName[64 + 1];

		//
		public int iRole;                                      //  2017/08/14

		//
		public Int64 startTime;
		//
		public ushort usRunningStatus;                         //  2007/06/07 

		public Int64 tLastModifiedTime;

		public fixed byte clientVer[Consts.CONST_qyMaxVerLen + 1];
		//
		public ushort shClientVer;             // clientVer[0-3];
		public byte blClientVer;               // clientVer[4-5];		//  2005/05/23, lhQwmVer  =  atol(  qwmVer  )  /  100;  llQwmVer  =  atol(  qwmVer  )  %  100;
		public byte b_mantissa_clientVer;      // clientVer[6-7]

		//
		public int iStatus;

	}
	;



//  ´Ë½á¹¹²»ÓÃÀ´´«Êä£¬Òª×ª»»³ÉÁ÷²Å½øÐÐ´«Êä
public unsafe struct QY_MESSENGER_REGINFO
	{
		public uint uiType;
		//
		public int id;

		public int iCustomId;

		//  TCHAR												misServName[CONST_maxMisServNameLen  +  1];
		//  QY_MESSENGER_ID									idInfo;
		public MSGR_ADDR addr;

		public fixed byte regTime[Consts.CONST_qyTimeLen + 1];
		public fixed byte auditTime[Consts.CONST_qyTimeLen + 1];
		public fixed byte tLastModifiedTime[Consts.CONST_qyTimeLen + 1];
		public fixed byte tCommitTime[Consts.CONST_qyTimeLen + 1];

		
		public fixed uint uiFieldIds[Consts.CONST_qnmMaxRegFields];
		/*
		union												{
					 //  WCHAR											cols[CONST_qnmMaxRegFields][256];
					 WCHAR cols[CONST_qnmMaxRegFields][64  +  1];		//  2007/12/01, ÒòÎªMIS_MSGU¹ý´ó£¬Ôì³Éstack overflow,¹Ê½«×Ö¶Î´óÐ¡ÏÞÖÆÔÚ64¸ö×Ö·û.
				 }	u;

				 void* pInternal;                           //  ÒÔÏÂÎªÄÚ²¿±äÁ¿£¬²»ÓÃÀ´Í¨ÐÅ
															//
	QNM_FIELD fields[CONST_qnmMaxRegFields];        //  2007/08/03, ´ú±íÁËÊý¾Ý¿âÀïµÄ´æ´¢Êý¾Ý
		*/
		public fixed char dw[Consts.CONST_maxNameLen + 1];
		public fixed char bm[Consts.CONST_maxNameLen + 1];
		public fixed char syr[Consts.CONST_maxNameLen + 1];

		//
		int index;
		public fixed char tmp_col[Consts.CONST_maxNameLen + 1];

}
;


	public unsafe struct REFRESH_imObjRule_reqMem
	{
		QY_MESSENGER_ID idInfo_related;
		uint uiRuleType;
		ushort usIndex;
		uint uiCmd;
		//  
		fixed char wDesc[128];           //  2011/11/13
	}
	;





//
public unsafe struct REFRESH_imObjRules_req
	{
		uint uiType;

		byte ucbResp;
		byte ucbRetrieveAll;

		ushort usMaxMemsPerSnd;         //  2011/11/13


		//					
		byte req_ucbNext;
		//
		QY_MESSENGER_ID req_idInfo_related;
		uint req_uiRuleType;
		ushort req_usIndex;
	
		
		//
		byte ucbEnd;


					 ushort usCnt_mems_tmpInternal;

		//
		ushort usCnt;
		//REFRESH_imObjRule_reqMem mems[MAX_imObjRule_reqMems];				 
		fixed byte buf_REFRESH_imObjRule_reqMem[Consts.CONST_bufSize_REFRESH_imObjRule_reqMem_mems];
}		 ;


//  2011/11/13. qm的全局策略，也是存在数据库里
public struct QY_im_rules
	{
	//  2011/10/15
	//  unsigned  char										ucbShareWebcamInConference;						//  是否在会议中共享摄像机. 如果选是，则在会议自动接收时，要弹出共享窗口
	QY_MESSENGER_ID conferenceId_shareWebcam;
	byte ucbNoLocalVideoInThisConference;              //  是否在这个会议中启动视频. 2011/10/22
																//
	byte ucbDistinguishSharedWebcams;                  //  是否区分被共享的摄像机，（是否使用序号）
																//
}
;

//  
public struct QY_imObj_rules
	{
	uint uiCmd_autoAnswer_av;
	uint uiCmd_autoAnswer_screen;   //  2010/12/18
	uint uiCmd_autoAnswer_mediaFile;    //  2010/12/18
}
;


//int imObjRulesReq2ImRules(REFRESH_imObjRules_req* pReq, QY_im_rules* pRules);
//int imObjRulesReq2Rules(REFRESH_imObjRules_req* pReq, QY_MESSENGER_ID* pIdInfo_related, QY_imObj_rules* pRules);


//  2010/08/13
public unsafe struct QY_imObjRule_rcd
	{
	int id;

	fixed char misServName[Consts.CONST_maxMisServNameLen + 1];
	QY_MESSENGER_ID idInfo;
	//
	uint uiRuleType;
	//
	ushort usIndex;
	QY_MESSENGER_ID idInfo_related;
	uint uiCmd;
	//
	Int64 startTime;
	Int64 tLastModifiedTime;
	//
	int iStatus;
	//
	fixed char col0[255 + 1];


}
;



/// <summary>
/// ////////////////////////////////////////////////////////////////////////
/// </summary>
/// 

public struct IM_SIMPLE_RESP
	{
		public uint uiType;
		public ushort usCmd_org;
		public uint uiContentType_org;
		public int iStatus;
		//
	}
	;

	public unsafe struct IM_HTML_CONTENT
	{                                   //  
		public uint uiType;                                //  
														   //
		public byte ucbResp;                          //  2014/07/11
													  //
													  //  2015/02/16
													  //unsigned  char										ucbNotification;
		public QY_MESSENGER_ID idInfo_logicalPeer;                 //  2015/02/16

		//  Int64											tStartTime_serv;					//  
		public uint uiSerialNo;                            //  
		public fixed char wBuf[Consts.cntof_imHtmlContent_wBuf];
	}
	;


	//  
	//  1 CONST_imCommType_transferFileInfo, 
	//  2 CONST_imCommType_transferFileInfoReply¸OK
	//  3 CONST_imCommType_transferDateReq¸CONST_imCommType_transferFileDataResp¸
	//  4 CONST_imCommType_transferFileDataEndResp¸

	//  2009/10/20
	public unsafe struct PROC_TASK_FILE
	{                                           //  video

		public void * hWnd_task;                                 //  2009/09/09

		public bool bTaskInvalid;                              //  2009/09/14

		//
		public bool bNeedRemoved;                              //  2015/09/08

	}
	;


	//  
	public unsafe struct TRANSFER_FILE_REQ
	{                                               //  2007/06/23
		public uint uiType;
		//
		public UInt64 ui64FileLen;
		public fixed char fileName[256];

		//
		public uint uiSizePerSnd_suggest;                          //  2014/07/13

		//  2015/08/05
		public ushort usSubtype;
		public QY_MESSENGER_ID idInfo_logicalPeer;                             //  2015/08/05

		//
		//  
		public void* pInternal;

		public PROC_TASK_FILE myTask;

		public fixed char fullFilePath[Consts.MAX_PATH + 1];       //  
																   //
		public bool bGrpTask;                          //  

		//
		//FILE* fp;
		public void* fp;

		//
		public uint dwStartTickCnt;                       //  
		public uint dwLastReportTickCnt;              //  
													  //
		public byte ucPercent;                            //  

		//
		public ushort usErrors;                            //  

		//
		public void* hTool_offlineRes;                  //  2015/08/06
		public bool bNeedCalcel;                       //  2015/08/08

	}
	;


//  »Ø¸´ÎÄ¼þ´«ËÍÐÅÏ¢
public unsafe struct TRANSFER_FILE_REPLYREQ
	{                                   //  2007/07/06
		public uint uiType;
		//
		public Int64 tStartTime_org;                     //  
		public uint uiTranNo_org;                      //
		public uint uiSerialNo_org;                        //  
														   //  
		public ushort usOp;
		//

		//  ÄÚ²¿´¦Àí
		public void* pInternal;

		public PROC_TASK_FILE myTask;                              //  2009/10/20

		//
		public UInt64 ui64FileLen;
		//
		public fixed char fileName_transferred[256 + 1];    //  
		public fixed char fullFilePath_save[Consts.MAX_PATH + 1];  //  
		public uint uiSizePerSnd_internal;             //  

		//FILE* fp;
		public void* fp;

		public uint uiLastDataBlockIndex;              //  
		public ushort usErrors;                            //  

		//
		public uint dwStartTickCnt;                       //  
		public uint dwLastReportTickCnt;              //  
													  //
		public byte ucPercent;                            //  


	}
	;	 	



public unsafe struct TASK_PROC_REQ
	{                                   //  2007/07/06
		public uint uiType;
		//
		public Int64 tStartTime_org;                     //  
		public uint uiTranNo_org;                      //
		public uint uiSerialNo_org;                        //  
														   //
		public uint uiContentType_org;                 //  2008/05/29
													   //  

		//
		public ushort usOp;

		//
		public ushort usTaskProcObjType;                       //  表明下面要操作的对象是什么

		//  2014/08/26. 也许这里应该引入一个objType，这样，就可以把清晰的指定要对什么做操作了.在要操作的对象多起来的时候，需要objType来区分下
		public uint uiTranNo_openAvDev_vStream;

		//  2009/09/11.  //  2014/08/26. 注意： 下面的几个变量uiTaskType,viewDynBmp，并没有在使用中，
#if true          //  2014/10/09. 启用
		public uint									uiTaskType;
		//
		public uint								uiObjType_viewDynBmp;
		public ushort							usIndex_obj_viewDynBmp;                         //  2009/09/06
#endif

		//  
		public void* pInternal;

		//
		//  char											fileName_save[MAX_PATH  +  1];

		//  2014/10/09
		public void* hWnd_task;

};
//TRANSFER_FILE_PROCREQ,  TRANSFER_FILE_procReq,  TASK_PROC_REQ;


//
public unsafe struct TASK_PROC_RESP
{
		public uint uiType;
		//
		public Int64 tStartTime_org;                     //  2009/10/19
		public uint uiTranNo_org;                      //
													   //
		public ushort usCmd_org;
		//  unsigned  int										uiContentType_org;
		//
		public ushort usOp_org;
		//
		public int iStatus;                            //  2009/10/19

		public QY_MESSENGER_ID idInfo_logicalPeer;                 //  2009/10/18

		//
		public void* pInternal;

		public bool bNeedRemoved;

}
	//TRANSFER_FILE_PROCRESP,  TRANSFER_FILE_procResp,  TASK_PROC_RESP;






	public unsafe struct TRANSFER_FILEDATA_REQ
	{                                   //  2007/07/15
		public uint uiType;
		//
		public Int64 tStartTime_org;                     //  ÇëÇó·¢ÆðµÄÊ±¼ä, ÕâÊÇÎªÁËÈ·¶¨ÊÇÄÄ¸öÈÎÎñ±»µÃµ½ÁËÔÊÐí
		public uint uiTranNo_org;                      //
		public uint uiSerialNo_org;                        //  Ã»Ê²Ã´ÓÃ
														   //
		public ushort usOp;
		//
		public uint uiSizePerSnd;                      //  Õâ´Î×î¶à·¢ËÍµÄ×Ö½ÚÊý, Ó¦¸ÃºÍReplyReqÖÐµÄÒ»Ñù
													   //
		public uint uiDataBlockIndex;                  //  µÚ¼¸¿éÊý¾Ý£¬´Ó0¿ªÊ¼

		//
		public void* pInternal;

		public bool ucbFileEnd;

	}
	;


public unsafe struct TRANSFER_FILEDATA_RESP
	{                                   //  2007/07/15
		public uint uiType;
		public uint uiDataBlockIndex;                  //  buf pInternal, 
		public uint uiLen;
		public fixed char buf[Consts.CONST_bufSize_transferFileDataResp];
		//

	}
	;


public unsafe struct TRANSFER_FILEEND_REQ
	{                                   //  2007/07/15
		public uint uiType;
		//
		public Int64 tStartTime_org;                     //  
		public uint uiTranNo_org;                      //
		public uint uiSerialNo_org;                        //  

		//  2015/09/07
		public bool tmpInternal_bChkToRemove_i;                       //  2015/09/07
																	  //
		public bool tmpInternal_bNeedRemoved_o;


}
;


public unsafe struct TRANSFER_FILEEND_RESP
{                                   //  2007/07/15
		public uint uiType;
		public uint uiVerifyMethod;                        //  
		public fixed char buf[2048];

		//  2015/09/07
		//
		public bool tmpInternal_bChkToRemove_i;
		//
		public bool tmpInternal_bNeedRemoved_o;

}				 ;



























//
public unsafe struct IM_L_STREAM
	{                                   //  2008/04/01
		public uint uiType;
		public uint uiContentType;
		public uint ulStreamLen;
		public fixed byte buf[Consts.CONST_bufSize_imLStream + 1];
	}
	;

//  2010/07/10
public unsafe struct IM_L_STREAM_nh
	{                                   //  2008/04/01
		public uint uiType;
		public uint uiContentType;
		public uint ulStreamLen;
		public fixed byte buf[1];
		public byte* p;
	}
	;


	public  struct QIS_INTERVAL_PARAMS
	{                                       //  2005/06/10
											//  unsigned  int										uiType;

		//  unsigned  short								usGetCfgInterval;

		public ushort usIntervalInS_refreshRecentFriends;
		public ushort usIntervalInS_refreshContactList;
		//				
	}
	;


//  2011/01/30
public struct QIS_getCfgs_req
	{
		public uint uiType;

		public byte ucbResp;

		public uint uiSizePerSnd_media;

		public QIS_INTERVAL_PARAMS intervalParams;

		//  2015/07/28
		//unsigned  char										ucbNotUseP2pCall;

	}
	;


	//  ¸
	//  
	//  1 ucbRetrieveImGrpList 
	//  2 RETRIEVE_IMGRPLIST_RESP
	//  3.ucbRetrieveImGrpList FALSE
	//  4 RETRIEVE_CONTACTLIST_RESP
	//	5 ucbRetrieveImGrpList FALSE
	//  6 RETRIEVE_CONTACTLIST_RESP
	//
	public struct RETRIEVE_IMOBJLIST_REQ
	{
		public uint uiType;
		public ushort usMaxContactUpdateInfosPerSnd;               //  Ò»´Î¿ÉÒÔÏÂÔØ×î¶à¶àÉÙ¸öÁªÏµÈË¸üÐÂÐÅÏ¢
		public Int64 tLastRefreshedTime_contactList_misServ;     //  ÉÏ´ÎµÄË¢ÐÂÊ±¼ä£¬Îª0Ê±£¬±íÃ÷È«ÃæË¢ÐÂ
																 //
		public byte ucbNext;                                  //  ÊÇ·ñ¼ÌÐøÇëÇó
		public QY_MESSENGER_ID idInfo_grp_lastRefreshed;                   //  ÉÏ´ÎË¢ÐÂµÄ×éID£¬½öÓÃÔÚË¢ÐÂ³ÉÔ±¹ØÏµ¡£
		public QY_MESSENGER_ID idInfo_lastRefreshed;                       //  ÉÏ´ÎµÄË¢ÐÂ½Úµã
	}
	;



	//  
	//

//
	public unsafe struct RETRIEVE_IMGRPLIST_RESP
	{
		public uint uiType;
		//
		public QY_MESSENGER_ID idInfo_lastRefreshed;                       //  ¶¼ÓÐ
																		   //
		public byte ucbEnd;                                       //  ÊÇ·ñÏìÓ¦Êý¾ÝÒÑ¾­½áÊø¡£

		public ushort usCnt;                                       //  ·Ç½áÊø°ü
																   //IM_GRP_INFO mems[Consts.CONST_maxContactUpdateInfos_grp];          //  ·Ç½áÊø°ü	
		public fixed byte buf_imGrpInfo_mems[Consts.CONST_bufSize_imGrpInfo_mems];

		//
		void* pInternal;                                    //  ÒÔÏÂÎªÄÚ²¿±äÁ¿£¬·ÇÕýÊ½Ê¹ÓÃ
		public int index;

	}
	;


public unsafe struct RETRIEVE_IMGRPMEMLIST_RESP
	{
		public uint uiType;
		//
		public QY_MESSENGER_ID idInfo_grp_lastRefreshed;                   //  ÒªË¢ÐÂµÄ×éID, Îª0Ê±±íË¢ÐÂËùÊô×éÐÅÏ¢¡£»òÕß£¬ÔÚ¹ÜÀí¶ËÃ»Æô¶¯×éÄ£Ê½Ê±£¬ÔòÏÂÔØËùÓÐ³ÉÔ±
		public QY_MESSENGER_ID idInfo_lastRefreshed;                       //  ¶¼ÓÐ
																		   //
		public byte ucbEnd;                                       //  ÊÇ·ñÏìÓ¦Êý¾ÝÒÑ¾­½áÊø¡£

		public ushort usCnt;                                       //  ·Ç½áÊø°ü
																   //IM_GRP_MEM mems[CONST_maxContactUpdateInfos_grpMem];            //  ·Ç½áÊø°ü	
		public fixed byte buf_imGrpMem_mems[Consts.CONST_bufSize_imGrpMem_mems];

		void* pInternal;                                    //  ÒÔÏÂÎªÄÚ²¿±äÁ¿£¬·ÇÕýÊ½Ê¹ÓÃ
		public int index;

	}
	;


//  2017/08/14
public struct RETRIEVE_contact_mem
	{
		public QY_MESSENGER_REGINFO regInfo;
		public int iRole;
	}
	;


//
public unsafe struct RETRIEVE_CONTACTLIST_RESP
	{
		public uint uiType;
		//
		public QY_MESSENGER_ID idInfo_lastRefreshed;                       //  ¶¼ÓÐ
																		   //
		public byte ucbEnd;                                       //  ÊÇ·ñÏìÓ¦Êý¾ÝÒÑ¾­½áÊø¡£

		public ushort usCnt;                                       //  ·Ç½áÊø°ü
																   //RETRIEVE_contact_mem mems[CONST_maxContactUpdateInfos_contact];         //  ·Ç½áÊø°ü	
		public fixed byte buf_retrieveContactMem_mems[Consts.CONST_bufSize_retrieveContaceMem_mems];

		//
		void* pInternal;            //  ÒÔÏÂÎªÄÚ²¿±äÁ¿£¬·ÇÕýÊ½Ê¹ÓÃ
		public int index;
		public int iFiledIndex;

	}
	;


public struct RETRIEVE_IMOBJLISTEND_RESP
	{                                           //  ½áÊø°ü
		public uint uiType;
		//
		public Int64 tLastRefreshedTime_contactList_misServ;     //  ·¢ËÍ¸ø¿Í»§¶ËÈÃÖªµÀÊÇ´ÓÊ²Ã´Ê±¼ä¿ªÊ¼Ë¢ÐÂµÄ
															//
	}
	;




	[StructLayout(LayoutKind.Explicit)]

	public struct IM_CONTENTU
	{                                   //  ÄÚ²¿´¦ÀíÊ±£¬¶¼²ÉÓÃwcharÀàÐÍ£¬·¢ËÍÒÔutf8·¢ËÍ
		[FieldOffset(0)]		public              uint uiType;                               //  ´ËÀàÐÍ¿ÉÒÔ¶à¸öÖµ£¬Çø·Öhtml,txtµÈ¸ñÊ½

		[FieldOffset(0)] public IM_SIMPLE_RESP simpleResp;
		//  IM_STREAM_CONTENT									stream;							//  2011/01/29
		//[FieldOffset(0)] public IM_DATA_CONTENT data;
		[FieldOffset(0)] public IM_L_STREAM lStream;
		//

		[FieldOffset(0)] public TRANSFER_FILE_REQ transferFileReq;
		[FieldOffset(0)] public TRANSFER_FILE_REPLYREQ transferFileReplyReq;                //  2007/07/06
		[FieldOffset(0)] public TRANSFER_FILEDATA_REQ transferFileDataReq;
		[FieldOffset(0)] public TRANSFER_FILEDATA_RESP transferFileDataResp;
		[FieldOffset(0)] public TRANSFER_FILEEND_REQ transferFileEndReq;
		[FieldOffset(0)] public TRANSFER_FILEEND_RESP transferFileEndResp;
		
	//
	[FieldOffset(0)]public TASK_PROC_REQ taskProcReq;
	[FieldOffset(0)]public TASK_PROC_RESP taskProcResp;
	//
	/*
	//
	REFRESH_RECENTFRIENDS_REQ refreshRecentFriendsReq;          //  2007/07/12
	REFRESH_RECENTFRIENDS_RESP refreshRecentFriendsResp;
	//
	RTC_CALL_REQ rtcCallReq;                            //  2007/10/07
														//
	TRANSFER_AV_INFO transferAvInfo;                        //  2008/03/15
	TRANSFER_AV_replyInfo transferAvReplyInfo;
	TRANSFER_VIDEO_DATA transferVideoData;
	TRANSFER_VIDEO_dataResp transferVideoDataResp;
	TRANSFER_AUDIO_DATA transferAudioData;                  //  2008/04/16
	TRANSFER_AUDIO_dataResp transferAudioDataResp;              //  2008/04/16
																//
	REMOTE_ASSIST_REQ remoteAssistReq;                  //  2008/11/15
														//
	TASK_INTERACTION_REQ taskInteractionReq;                    //  2009/02/23
	VIDEO_CONFERENCE_STATUS videoConferenceStatus;
	VIDEO_CONFERENCE_LAYOUT videoConferenceLayout;              //  2010/12/27
	CONF_state confState;                           //  2017/09/17
													//
	TRANSFER_GPS_INFO transferGpsInfo;                  //  2012/04/19
	TRANSFER_GPS_replyInfo transferGpsReplyInfo;                //  2012/04/19
	TRANSFER_GPS_DATA transferGpsData;                  //  2012/04/20
	TRANSFER_GPS_dataResp transferGpsDataResp;              //  2012/04/20
															//
															//  stream
															//
		*/
		[FieldOffset(0)] public IM_HTML_CONTENT html;
	//
	//  QIS_INTERVAL_PARAMS							intervalParams;						//  2007/12/01
		
	[FieldOffset(0)]public QIS_getCfgs_req getCfgsReq;                         //  2011/01/30
			
	[FieldOffset(0)]public RETRIEVE_IMOBJLIST_REQ retrieveImObjListReq;
		[FieldOffset(0)] public RETRIEVE_IMGRPLIST_RESP retrieveImGrpListResp;
		[FieldOffset(0)] public RETRIEVE_IMGRPMEMLIST_RESP retrieveImGrpMemListResp;
		[FieldOffset(0)] public RETRIEVE_CONTACTLIST_RESP retrieveContactListResp;
		[FieldOffset(0)] public RETRIEVE_IMOBJLISTEND_RESP retrieveImObjListEndResp;
		/*											//
	//
	IM_GRP_EX imGrpEx;
	//
	RETRIEVE_customerServiceObjList_req retrieveCustomerServiceObjListReq;  //  2011/04/04
	QUERY_customerServiceOfficer_req queryCustomerServiceOfficerReq;        //  2011/04/06
	QUERY_customerServiceOfficer_replyReq queryCustomerServiceOfficerReplyReq;//  2011/04/06
																			  //
	RETRIEVE_WEBCONTACTLIST_RESP retrieveWebContactListResp;
	REFRESH_WEBCONTACTS_INFO refreshWebContactsInfo;                //  2007/12/22
																	//
	QY_VDEV_COMS vDevComs;
	RETRIEVE_SM_POLICY retrieveSmPolicy;
	RETRIEVE_PHONE_MSGRS retrievePhoneMsgrs;                    //  2008/01/02
	RETRIEVE_TO_PATHS retrieveToPaths;                  //  2008/02/09
														//
	REFRESH_DYN_BMPS refreshDynBmps;                        //  2009/08/24
	VERIFY_viewDynBmp verifyViewDynBmp;                 //  2011/10/31
	RETRIEVE_DYN_BMPS retrieveDynBmps;                  //  2009/09/04
	REFRESH_imObjRules_req refreshImObjRulesReq;                //  2010/08/15
																//
	PROC_offlineRes_u procOfflineResU;                  //  2015/08/01


	//
	PTZ_control_req ptzControlReq;                      //  2012/08/05
	PTZ_control_cmd ptzControlCmd;

	//
	QUERY_peer_status queryPeerStatus;                  //  2014/07/11

	//
	QY_VDEV_DATA vDevData;

	//
	GET_daemonStatus_req getDaemonStatusReq;                    //  2011/01/08

		*/
	}
;


	[StructLayout(LayoutKind.Explicit)]

	public struct IM_CONTENTU_nh
	{									//  2010/07/29
				 [FieldOffset (0)]public uint										uiType;                             //  
		[FieldOffset(0)] public IM_SIMPLE_RESP simpleResp;
		[FieldOffset(0)] public IM_L_STREAM_nh lStream;
}		 ;



	//////////////////////////////////////////
	///

	public unsafe struct QIS_EVENT
	{
		int id;
		int lHelpRand;                                     //	2003/11/15
															//
		fixed char misServName[Consts.CONST_maxMisServNameLen + 1];
		QY_MESSENGER_ID idInfo;
		//				 
		fixed byte detectedIp[15 + 1];                            //  Í¨ÐÅ¼ì²âµ½µÄ¿Í»§¶ËIP
		fixed byte ip[15 + 1];                                    //  ip must be filled before qnmLogPcEvent
		int lEventType;                                        //  eventType must be filled before qnmLogPcEvent
		int iCustomId;                                      //  iCustomId must be filled before qnmLogPcEvent
		fixed byte localEventTime[14 + 1];                                    //  localEventTime must be filled before qnmLogPcEvent
		fixed byte localCntEventTime[14 + 1];                             //  ´«Èë¹ÜÀíÖÐÐÄµÄ±¾µØµÄÊ±¼ä
		fixed byte cntEventTime[14 + 1];                                  //  ´«Èë¹ÜÀíÖÐÐÄµÄ¹ÜÀíÖÐÐÄµÄÊ±¼ä
		fixed char comment[255 + 1];
		//char cols[CONST_qnmMaxEventRegFields][255  +  1];	//  ÊÂ¼þ´¥·¢ÕßµÄÐÅÏ¢10ÁÐ   
		fixed 		 char usrName[255 + 1];
		//
		//TCHAR deses[CONST_qnmMaxEventDesFields][255  +  1];	//  ÊÂ¼þÃèÊö±¾ÉíµÄÐÅÏ¢10ÁÐ				 
		fixed 		 char dsnName[128 + 1];                                //  2007/01/02
		int iStatus;                                        //  2006/06/02, Ôö¼Ó¶ÔÊÂ¼þµÄ´¦Àí×´Ì¬µÄÃèÊö
	}
	;		




	/// <summary>
	/// /////////////////////////////////////////////
	/// </summary>

	public unsafe struct MIS_MSG_TALKDATA
	{
		public MSG_SIMPLE_ROUTE route; //  TALKDATA_ADDR									addr;
								//
								//fixed char buf[sizeof(IM_CONTENTU) + 1024];   //  ×¢Òâ£¬ÔÚ·ÅÈë¶ÓÁÐÀï£¬²»ÒªÓÃsizeof(  data  ),  Ó¦¸ÃÊ¹ÓÃoffsetof(  ,  data  )  +  dataLen, ÒÔ½ÚÔ¼ÄÚ´æ
		public fixed byte buf[Consts.CONST_bufSize_talkData];
	}
	;

	public unsafe struct MIS_MSG_routeTalkData
	{
		public MSG_ROUTE route;
		//
		//char buf[sizeof(IM_CONTENTU) + 1024];
		public fixed byte buf[Consts.CONST_bufSize_routeTalkData];
	}
	;





	/// <summary>
	/// /////////////////////////////////////////
	/// </summary>


	public struct MIS_MSG_TALK
	{                                   //  2007/11/29, addressable talk
		public uint uiType;
		//
		public uint uiCliIndex;                           //  input daemon
														  //  2008/01/05, vDev_coms uiCliIndex

		public uint uiSessionId;
		public uint uiStep;                                //  2008/04/28

		public bool ucbConvrted;                      //  input 2007/7/14

		public bool ucbConvrted_msgRoute;             //  daemon input 
		public ushort lenInBytes_msgRouteInDataBuf;        //  daemon input data.route route data.buf
														   //  lenInBytes_msgRouteInDataBuf data.buf route

		//  mc MisCnt qmd uiCliIndex, 2007/06/10
		//void* pMisCnt;                          //  misCntµÄ, 2007/06/02
		public MSGR_ADDR addr_logicalPeer;                 //  messenger. 

		//
		public byte ucFlg;
		//
		public ushort usCode;
		public ushort usCode_org;                          //  
		public Int64 tStartTime;
		public uint uiTranNo;
		public ushort usSeqNo;

		public Int64 tStartTime_processed;                //  iocp uiTranNo_mgr iocp
		public uint uiTranNo_processed;
		public uint nTimes_tryToSend;                  //  mgr iocp 
													   //
		public Int64 tTime_alive;                     //  2014/12/09. 当没有找到新的视频数据时，刷新此变量，也可以表明任务是活跃的
													  //
		public Int64 tTime_applyForChkTaskAlive;          //  2010/10/30
		public byte nTimes_applyForChkTaskAlive;      //  2014/12/09

		//
		public uint uiTaskMode_unused;                 //  2009/08/23

		//
		public int iTaskId;                            //  
		public uint uiTaskType;                            //  
		public QY_MESSENGER_ID idInfo_taskSender;                  //  
		public QY_MESSENGER_ID idInfo_taskReceiver;                //  
		public int iStatus;                            //  2007/07/18
		public Int64 tLastModifiedTime;                   //  2014/05/01

		//  
		public Int64 tRecvTime;                           //  
		public uint dwTickCnt_start;                  //  ( ms ). 
		public uint dwTickCnt_toSend;                 //  2011/01/22. start->toSendQ
													  //  
		public ushort usElapsed_recved;                    //  
		public ushort usElapsed_serv_startToProcess;       //  mtMgrThreadProc_is 
		public int index_debugInfo;                    //  debugInfo index, debugInfo 2008/11/19

		//
		public uint uiChannelType;                     //  2008/04/17, 
													   //
		public uint uiChannelType_input;               //  2017/10/03

		//
		public uint lenInBytes;
		//
		public MIS_MSG_routeTalkData data;                             //  sizeof(  data  ),  offsetof(  ,  data  )  +  offsetof(  MIS_MSG_TALKDATA,  buf  )  +  bufLen
	};
	//MIS_MSG_TALK, MIS_MSG_INPUT, MIS_MSG_TASK, MIS_MSG_REQ;	

	public struct MIS_MSG_INPUT
	{                                   //  2007/11/29, addressable talk
		public uint uiType;
		//
		public uint uiCliIndex;                           //  input daemon
														  //  2008/01/05, vDev_coms uiCliIndex

		public uint uiSessionId;
		public uint uiStep;                                //  2008/04/28

		public bool ucbConvrted;                      //  input 2007/7/14

		public bool ucbConvrted_msgRoute;             //  daemon input 
		public ushort lenInBytes_msgRouteInDataBuf;        //  daemon input data.route route data.buf
														   //  lenInBytes_msgRouteInDataBuf data.buf route

		//  mc MisCnt qmd uiCliIndex, 2007/06/10
		//void* pMisCnt;                          //  misCntµÄ, 2007/06/02
		public MSGR_ADDR addr_logicalPeer;                 //  messenger. 

		//
		public byte ucFlg;
		//
		public ushort usCode;
		public ushort usCode_org;                          //  
		public Int64 tStartTime;
		public uint uiTranNo;
		public ushort usSeqNo;

		public Int64 tStartTime_processed;                //  iocp uiTranNo_mgr iocp
		public uint uiTranNo_processed;
		public uint nTimes_tryToSend;                  //  mgr iocp 
													   //
		public Int64 tTime_alive;                     //  2014/12/09. 当没有找到新的视频数据时，刷新此变量，也可以表明任务是活跃的
													  //
		public Int64 tTime_applyForChkTaskAlive;          //  2010/10/30
		public byte nTimes_applyForChkTaskAlive;      //  2014/12/09

		//
		public uint uiTaskMode_unused;                 //  2009/08/23

		//
		public int iTaskId;                            //  
		public uint uiTaskType;                            //  
		public QY_MESSENGER_ID idInfo_taskSender;                  //  
		public QY_MESSENGER_ID idInfo_taskReceiver;                //  
		public int iStatus;                            //  2007/07/18
		public Int64 tLastModifiedTime;                   //  2014/05/01

		//  
		public Int64 tRecvTime;                           //  
		public uint dwTickCnt_start;                  //  ( ms ). 
		public uint dwTickCnt_toSend;                 //  2011/01/22. start->toSendQ
													  //  
		public ushort usElapsed_recved;                    //  
		public ushort usElapsed_serv_startToProcess;       //  mtMgrThreadProc_is 
		public int index_debugInfo;                    //  debugInfo index, debugInfo 2008/11/19

		//
		public uint uiChannelType;                     //  2008/04/17, 
													   //
		public uint uiChannelType_input;               //  2017/10/03

		//
		public uint lenInBytes;
		//
		public MIS_MSG_routeTalkData data;                             //  sizeof(  data  ),  offsetof(  ,  data  )  +  offsetof(  MIS_MSG_TALKDATA,  buf  )  +  bufLen
	};
	

	public struct MIS_MSG_TASK
	{                                   //  2007/11/29, addressable talk
		public uint uiType;
		//
		public uint uiCliIndex;                           //  input daemon
														  //  2008/01/05, vDev_coms uiCliIndex

		public uint uiSessionId;
		public uint uiStep;                                //  2008/04/28

		public bool ucbConvrted;                      //  input 2007/7/14

		public bool ucbConvrted_msgRoute;             //  daemon input 
		public ushort lenInBytes_msgRouteInDataBuf;        //  daemon input data.route route data.buf
														   //  lenInBytes_msgRouteInDataBuf data.buf route

		//  mc MisCnt qmd uiCliIndex, 2007/06/10
		//void* pMisCnt;                          //  misCntµÄ, 2007/06/02
		public MSGR_ADDR addr_logicalPeer;                 //  messenger. 

		//
		public byte ucFlg;
		//
		public ushort usCode;
		public ushort usCode_org;                          //  
		public Int64 tStartTime;
		public uint uiTranNo;
		public ushort usSeqNo;

		public Int64 tStartTime_processed;                //  iocp uiTranNo_mgr iocp
		public uint uiTranNo_processed;
		public uint nTimes_tryToSend;                  //  mgr iocp 
													   //
		public Int64 tTime_alive;                     //  2014/12/09. 当没有找到新的视频数据时，刷新此变量，也可以表明任务是活跃的
													  //
		public Int64 tTime_applyForChkTaskAlive;          //  2010/10/30
		public byte nTimes_applyForChkTaskAlive;      //  2014/12/09

		//
		public uint uiTaskMode_unused;                 //  2009/08/23

		//
		public int iTaskId;                            //  
		public uint uiTaskType;                            //  
		public QY_MESSENGER_ID idInfo_taskSender;                  //  
		public QY_MESSENGER_ID idInfo_taskReceiver;                //  
		public int iStatus;                            //  2007/07/18
		public Int64 tLastModifiedTime;                   //  2014/05/01

		//  
		public Int64 tRecvTime;                           //  
		public uint dwTickCnt_start;                  //  ( ms ). 
		public uint dwTickCnt_toSend;                 //  2011/01/22. start->toSendQ
													  //  
		public ushort usElapsed_recved;                    //  
		public ushort usElapsed_serv_startToProcess;       //  mtMgrThreadProc_is 
		public int index_debugInfo;                    //  debugInfo index, debugInfo 2008/11/19

		//
		public uint uiChannelType;                     //  2008/04/17, 
													   //
		public uint uiChannelType_input;               //  2017/10/03

		//
		public uint lenInBytes;
		//
		public MIS_MSG_routeTalkData data;                             //  sizeof(  data  ),  offsetof(  ,  data  )  +  offsetof(  MIS_MSG_TALKDATA,  buf  )  +  bufLen
	};
	


	public struct MIS_MSG_REQ
	{                                   //  2007/11/29, addressable talk
		public uint uiType;
		//
		public uint uiCliIndex;                           //  input daemon
														  //  2008/01/05, vDev_coms uiCliIndex

		public uint uiSessionId;
		public uint uiStep;                                //  2008/04/28

		public bool ucbConvrted;                      //  input 2007/7/14

		public bool ucbConvrted_msgRoute;             //  daemon input 
		public ushort lenInBytes_msgRouteInDataBuf;        //  daemon input data.route route data.buf
														   //  lenInBytes_msgRouteInDataBuf data.buf route

		//  mc MisCnt qmd uiCliIndex, 2007/06/10
		//void* pMisCnt;                          //  misCntµÄ, 2007/06/02
		public MSGR_ADDR addr_logicalPeer;                 //  messenger. 

		//
		public byte ucFlg;
		//
		public ushort usCode;
		public ushort usCode_org;                          //  
		public Int64 tStartTime;
		public uint uiTranNo;
		public ushort usSeqNo;

		public Int64 tStartTime_processed;                //  iocp uiTranNo_mgr iocp
		public uint uiTranNo_processed;
		public uint nTimes_tryToSend;                  //  mgr iocp 
													   //
		public Int64 tTime_alive;                     //  2014/12/09. 当没有找到新的视频数据时，刷新此变量，也可以表明任务是活跃的
													  //
		public Int64 tTime_applyForChkTaskAlive;          //  2010/10/30
		public byte nTimes_applyForChkTaskAlive;      //  2014/12/09

		//
		public uint uiTaskMode_unused;                 //  2009/08/23

		//
		public int iTaskId;                            //  
		public uint uiTaskType;                            //  
		public QY_MESSENGER_ID idInfo_taskSender;                  //  
		public QY_MESSENGER_ID idInfo_taskReceiver;                //  
		public int iStatus;                            //  2007/07/18
		public Int64 tLastModifiedTime;                   //  2014/05/01

		//  
		public Int64 tRecvTime;                           //  
		public uint dwTickCnt_start;                  //  ( ms ). 
		public uint dwTickCnt_toSend;                 //  2011/01/22. start->toSendQ
													  //  
		public ushort usElapsed_recved;                    //  
		public ushort usElapsed_serv_startToProcess;       //  mtMgrThreadProc_is 
		public int index_debugInfo;                    //  debugInfo index, debugInfo 2008/11/19

		//
		public uint uiChannelType;                     //  2008/04/17, 
													   //
		public uint uiChannelType_input;               //  2017/10/03

		//
		public uint lenInBytes;
		//
		public MIS_MSG_routeTalkData data;                             //  sizeof(  data  ),  offsetof(  ,  data  )  +  offsetof(  MIS_MSG_TALKDATA,  buf  )  +  bufLen
	};
	


	public struct MIS_MSG_procVideo_qmc
{                                   //  2008/03/18
	//MACRO_misMsg_common
	public uint uiType;
		//
		//		void* pMisCnt;
		public QY_MESSENGER_ID idInfo_peer;
	//
						UInt64                       ui64Id_idInfo_sender;
		//
		//
		public uint uiTranNo_openAvDev;
		public ushort usIndex;
		//
		public int iTaskId;
		public IntPtr hWnd_task;                         //  2009/09/14
														 //
		public uint uiEventId_lastRecvd_unused;            //  2016/12/26	//  2008/11/22

		//
		public uint uiCapType;
		public int iIndex_capProcInfo;
		public BITMAPINFOHEADER bih;

		//
		//QY_MEMORY									memory;

		//  2014/09/23
		public myDRAW_VIDEO_DATA pkt;

		//
		//  int										index_player;						//  2009/10/03
		public PLAYER_ID playerId;                         //  2016/02/18

		//

		//
		public bool ucbDisplayAllFrames;              //  2009/07/25

//

//  

}		;


	[StructLayout(LayoutKind.Explicit)]

	public struct  MIS_MSGU										{
		[FieldOffset(0)] public uint uiType;
		/*
		MIS_MSG_RESULT result;
		MIS_MSG_RESP resp;
		*/
		[FieldOffset(0)] public MIS_MSG_INPUT input;
		[FieldOffset(0)] public MIS_MSG_REQ req;
		[FieldOffset(0)] public MIS_MSG_TALK talk;
		[FieldOffset(0)] public MIS_MSG_TASK task;                      //  2007/07/08
		
		/*
		//
	MIS_MSG_GRP grp;                        //  2008/05/27
											//
	MIS_MSG_inputArrive inputArrive;                //  2015/08/24
	MIS_MSG_send send;                      //  2015/09/02
	MIS_MSG_sendFinished sendFinished;              //  2007/05/30
	MIS_MSG_processSelf processSelf;                //  2007/05/30
	MIS_MSG_processBt processBt;                    //  2011/04/18
	MIS_MSG_isSendOk isSendOk;
	MIS_MSG_sendOk sendOk;
	MIS_MSG_chkChannel chkChannel;                  //  2007/12/20
	MIS_MSG_applyForWork applyForWork;              //  2007/09/03
													//
	MIS_MSG_NEEDREG_QMC needReg_qmc;
	//
	MIS_MSG_TASKSTATUS taskStatus;                  //  2007/07/17
	MIS_MSG_imMsgRcd imMsgRcd;                  //  2007/08/12
	MIS_MSG_EVENT event;
	//
	MIS_MSG_TALKINGFRIEND_QMC talkingFriend_qmc;
	MIS_MSG_RECENTFRIEND_QMC recentFriend_qmc;
	MIS_MSG_DISPLAYEDELEM_QMC displayedElem_qmc;            //  2007/06/10
	MIS_MSG_REFRESHCONTACTSSTATUS_QMC refreshContactsStatus_qmc;
	MIS_MSG_REFRESHMESTATUS_QMC refreshMeStatus_qmc;        //  2007/06/20
	MIS_MSG_applyForPlayer_qmc applyForPlayer_qmc;          //  2008/05/09
	MIS_MSG_applyForChkChannels_qmc applyForChkChannels_qmc;    //  2008/06/01
	MIS_MSG_applyForRemovingInvalidTasks_qmc applyForRemovingInvalidTasks_qmc;      //  2009/09/10
	MIS_MSG_applyForTalkerShadow_qmc applyForTalkerShadow_qmc;  //  2012/04/23
																//
	MIS_MSG_procVideo_qmc procVideo;                    //  2009/03/24
	MIS_MSG_procGps_qmc procGps;                    //  2012/04/20
													//
	MIS_MSG_notifyTaskEnd_qmc notifyTaskEnd;                //  2009/04/28
															//
	MIS_MSG_getDaemonStatus getDaemonStatus;            //  2011/01/12
	*/

	}
	;



	partial class qyFuncs
	{
		public unsafe struct TMP_ip
		{
			public fixed byte ip[Consts.CONST_qyMaxIpLen + 1];
		}
		public static unsafe int qnmOpenSession_mis(string servIp, ushort usPort, ref QY_COMM_AUTHINFO_MIS pAuthInfo, byte ucAuthCmd, uint uiChannelType, string clientIp, int iServiceId, string serviceVer, ref ENC_CTX_session pCommEncCtx, ref QY_COMM_SESSION pSession, ref QY_SOCK pSock, SOCK_TIMEOUT pTo, byte* data, uint* piDataSize)
		{
			int iErr = -1;
			QY_COMM_AUTHINFO_MIS authInfo;
			TMP_ip ip;
			byte* pIp = ip.ip;
			QY_MSG_HEAD tmpResp; tmpResp.uiLen = 0;
			TMP_buf4096 tmpBuf4096;
			uint len;

			if (0 == usPort) return -1;
			if (0 == ucAuthCmd)
			{
				/*
				if (!pAuthInfo)
				{
					traceLogA("qnmOpenSession_mis failed: pAuthInfo is null");
					return -1;
				}
				*/
			}

			//if (pAuthInfo) memcpy(&authInfo, pAuthInfo, sizeof(authInfo));
			//else memset(&authInfo, 0, sizeof(authInfo));
			authInfo = pAuthInfo;
			//
			if (!bQySockOpen(ref pSock))
			{       //  Èç¹ûÇ°ÃæÒÑ½¨Á¢Á¬½Ó£¬Ôò²»ÐèÒª½¨Á¢ÐÂÁ¬½Ó
				if (qyConnect(servIp, usPort, ref pTo, ref pSock) != 0) goto errLabel;
			}
			authInfo.ucCmd = ucAuthCmd;
			authInfo.uiChannelType = uiChannelType; //  2007/07/08
													//
			if (bIpValid(clientIp)) safeStrnCpy(clientIp, (byte*)authInfo.ip, Consts.CONST_qyMaxIpLen + 1);
			else
			{
				if (getLocalIpBySocket(ref pSock, ip.ip) != 0) goto errLabel;
				safeStrnCpy(mytoString(pIp), authInfo.ip, Consts.CONST_qyMaxIpLen + 1);
			}

			//  ½«»á»°ÃÜÔ¿·ÅÈëauthInfoÁ÷ÖÐ£¬2008/06/10
			//if (pCommEncCtx )
			{
				ref ENC_CTX_session pEncCtx = ref pCommEncCtx;
				if (pEncCtx.common.type == Consts.CONST_qyEncType_rsa
					&& pEncCtx.uiBlobLen_sessionKey != 0)
				{
					authInfo.uiBlobLen_sessionKey = Math.Min(pEncCtx.uiBlobLen_sessionKey, Consts.CONST_bufSize_sessionKeyBlob);
					fixed (byte* psrc = pEncCtx.sessionKeyBlob)
					{
						byte* pdst = authInfo.sessionKeyBlob;
						mymemcpy((IntPtr)pdst, (IntPtr)psrc, authInfo.uiBlobLen_sessionKey);
					}
				}
				//  2015/08/28
			}
			//
			len = Consts.CONST_bufSize_4096;// sizeof(tmpBuf);
			if (0 != commAuthInfo2Stream_mis(&authInfo, tmpBuf4096.buf, &len)) goto errLabel;

			fixed (byte* pclientIp = pSession.clientIp)
			{
				safeStrnCpy(mytoString(pIp), pclientIp, Consts.CONST_qyMaxIpLen + 1); //  2007/08/03
			}

			Int64 tStartTran; uint uiTranNo;
			MACRO_prepareForTran(out tStartTran, out uiTranNo);
			

			//  if  (  qyTellService_msg(  iServiceId,  serviceVer,  CONST_qyCmd_tellService,  pCommEncCtx,  tmpBuf,  len,  pSock,  pTo,  pSession  )  )  goto  errLabel;
			if (0 != qyTellService_msg((uint)iServiceId, serviceVer, ref pCommEncCtx.common, Consts.CONST_qyCmd_tellService, tStartTran, uiTranNo, tmpBuf4096.buf, (int)len, pSock, pTo, pSession)) goto errLabel;
			if (0 != qyRecvMsg(ref pSession, ref pSock, pTo, &tmpResp, tmpBuf4096.buf, Consts.CONST_bufSize_4096)) goto errLabel;
			//  traceLogA(  "qwmOpenSession: get respCode of qyTellService is %s",  qyGetDesByType1(  CONST_qyRcTable,  tmpResp.head.usCode  )  );

			//  2011/10/27
			if (tmpResp.i64StartTime != tStartTran
				|| tmpResp.uiTranNo != uiTranNo)
			{

				goto errLabel;
			}

			//  if  (  !isRcOk(  tmpResp.head.usCode  )  )  goto  errLabel; 

			iErr = 0;

		errLabel:

			if (0 != iErr)
			{
				if (bQySockOpen(ref pSock)) qyDisconnect(ref pSock);
			}
			else
			{
				if (piDataSize != null && data != null)
				{
					*piDataSize = Math.Min(*piDataSize, tmpResp.uiLen);
					mymemcpy((IntPtr)data, (IntPtr)tmpBuf4096.buf, *piDataSize);
				}
			}

			return iErr;
		}


		//
		public static unsafe void MACRO_memset_misMsgTalk(MIS_MSG_TALK* pMsgTalk) {
			//memset(  (  pMsgTalk  ),  0,  offsetof(  MIS_MSG_TALK,  data  )  +  offsetof(  MIS_MSG_routeTalkData,  buf  )  +  sizeof(  unsigned  int  )  );
			mymemset((IntPtr)pMsgTalk, 0, sizeof(MIS_MSG_TALK) - Consts.CONST_bufSize_routeTalkData);
		}
		public static unsafe void MACRO_memset_misMsgInput(MIS_MSG_INPUT* pMsgInput) {
			//memset(  (  pMsgInput  ),  0,  offsetof(  MIS_MSG_INPUT,  data  )  +  offsetof(  MIS_MSG_routeTalkData,  buf  )  +  sizeof(  unsigned  int  )  );
			mymemset((IntPtr)pMsgInput, 0, sizeof(MIS_MSG_INPUT) - Consts.CONST_bufSize_routeTalkData);
		}
		public static unsafe void MACRO_memset_misMsgTask(MIS_MSG_TASK* pMsgTask) {
			//memset(  (  pMsgTask  ),  0,  offsetof(  MIS_MSG_TASK,  data  )  +  offsetof(  MIS_MSG_routeTalkData,  buf  )  +  sizeof(  unsigned  int  )  );
			mymemset((IntPtr)pMsgTask, 0, sizeof(MIS_MSG_TASK) - Consts.CONST_bufSize_routeTalkData);
		}
		public static unsafe void MACRO_memset_misMsgReq(MIS_MSG_REQ* pMsgReq)
		{
			//memset(  (  pMsgReq  ),  0,  offsetof(  MIS_MSG_REQ,  data  )  +  offsetof(  MIS_MSG_routeTalkData,  buf  )  +  sizeof(  unsigned  int  )  );
			mymemset((IntPtr)pMsgReq, 0, sizeof(MIS_MSG_REQ) - Consts.CONST_bufSize_routeTalkData);
		}

		//
		public static unsafe void MACRO_memset_imLStream(IM_L_STREAM* pStream)
		{
			mymemset((IntPtr)(pStream), 0, (int)Marshal.OffsetOf<IM_L_STREAM>("buf"));
		}


		public static unsafe MIS_MSG_routeTalkData* MACRO_msgRouteTalkData(byte ucFlg, MIS_MSG_routeTalkData* pMsgData)
		{
			//(  (  isUcFlgRouteTalkData(  ucFlg  )  ||  isUcFlgTalkData(  ucFlg  )  )  ?  pMsgBuf  :  NULL  )
			return ((isUcFlgRouteTalkData(ucFlg) || isUcFlgTalkData(ucFlg)) ? pMsgData : null);
		}
		//  2014/09/28
		//  #define		M_getMsgContent(  ucFlg,  pMsgBuf  )				(  (  isUcFlgRouteTalkData(  ucFlg  )  ||  isUcFlgTalkData(  ucFlg  )  )  ?  (  (  IM_CONTENTU  *  )(  (  MIS_MSG_routeTalkData  *  )pMsgBuf  )->buf  )  :  (  IM_CONTENTU  *  )pMsgBuf  )
		public static unsafe IM_CONTENTU* M_getMsgContent(byte ucFlg, void* pMsgData)
		{
			//(  (  isUcFlgRouteTalkData(  ucFlg  )  ||  isUcFlgTalkData(  ucFlg  )  )  ?  (  (  IM_CONTENTU  *  )(  (  MIS_MSG_routeTalkData  *  )pMsgData  )->buf  )  :  (  IM_CONTENTU  *  )pMsgData  )
			return ((isUcFlgRouteTalkData(ucFlg) || isUcFlgTalkData(ucFlg)) ? ((IM_CONTENTU*)((MIS_MSG_routeTalkData*)pMsgData)->buf) : (IM_CONTENTU*)pMsgData);
		}

		//
		public static unsafe void MACRO_qyNullThread(ref Thread h)
		{
			//if  (  h  )  {	::WaitForSingleObject(h, INFINITE  );	CloseHandle(h  ); h	=	NULL;	}												
			if (h != null)
			{
				int i;
				int maxStep = 10000;
				for (i = 0; i < maxStep; i++)
				{
					if (!h.IsAlive) break;
					Thread.Sleep(100);
					continue;

				}
				if (i == maxStep)
				{
					int ii = 0;
					showInfo_open(null, "MACRO_qyNullThread", "failed, serious err");
				}
				h = null;
			}
			return;
		}











		/// <summary>
		/// //////////////////////////////////////////
		/// </summary>
		/// <param name="lhClientVer"></param>
		/// <param name="p"></param>
		/// <returns></returns>
		/// 

		public static unsafe int qyhtonImSimpleResp(int lhClientVer, IM_SIMPLE_RESP* p)
		{
			p->uiType = qyhtoni(p->uiType);
			p->usCmd_org=qyhtons(p->usCmd_org);
			p->uiContentType_org=qyhtoni(p->uiContentType_org);
			p->iStatus=qyhtoni(p->iStatus);
			//
			//  MACRO_htonl64(  p->tStartTime_org  );		//  2009/10/17
			//  MACRO_htonl(  p->uiTranNo_org  );
			//
			return sizeof(IM_SIMPLE_RESP);
		}

		public static unsafe int qyntohImSimpleResp(int lhClientVer, IM_SIMPLE_RESP* p)
		{
			p->uiType=qyntohi(p->uiType);
			p->usCmd_org=qyntohs(p->usCmd_org);
			p->uiContentType_org=qyntohi(p->uiContentType_org);
			p->iStatus=qyntohi(p->iStatus);
			//
			//  MACRO_ntohl64(  p->tStartTime_org  );		//  2009/10/17
			//  MACRO_ntohl(  p->uiTranNo_org  );
			//
			return sizeof(IM_SIMPLE_RESP);
		}


		/////


		public static unsafe int qyhtonImLStream(int lhClientVer, IM_L_STREAM* p)
		{
			int len = -1;

			int tmp_l;
			//memcpy(&tmp_l, &p->ulStreamLen, sizeof(long));
			tmp_l = (int)p->ulStreamLen;
			if (tmp_l > Consts.CONST_bufSize_imLStream  )  return -1;

			len = (int)Marshal.OffsetOf<IM_L_STREAM>("buf") + tmp_l;   //  p->ulStreamLen;

			p->uiType=qyhtoni(p->uiType);
			p->uiContentType=qyhtoni(p->uiContentType);
			p->ulStreamLen=qyhtoni(p->ulStreamLen);

			return len;
		}

		public static unsafe int qyntohImLStream(long lhClientVer, byte* p, IM_L_STREAM_nh* pStream)
		{
			int len = -1;

			if (null==p || null==pStream)
			{
				traceLog(("qyntohImLStream failed, p or pStream is null"));
				return -1;
			}

			mymemset((IntPtr)pStream, 0, sizeof(IM_L_STREAM_nh));
			mymemcpy((IntPtr)pStream, (IntPtr)p, (uint)Marshal.OffsetOf<IM_L_STREAM_nh>("buf"));

			pStream->uiType=qyntohi(pStream->uiType);
			pStream->uiContentType=qyntohi(pStream->uiContentType);
			pStream->ulStreamLen=qyntohi(pStream->ulStreamLen);

			//
			pStream->p = p + (int)Marshal.OffsetOf<IM_L_STREAM>("buf");

			//  if  (  p->ulStreamLen  >  sizeof(  p->buf  )  )  return  -1;
			uint tmp_ul;
			//memcpy(&tmp_ul, &pStream->ulStreamLen, sizeof(tmp_ul));
			tmp_ul = pStream->ulStreamLen;
			if (tmp_ul > Consts.CONST_bufSize_imLStream) return -1;

			//  len  =  offsetof(  IM_L_STREAM,  buf  )  +  p->ulStreamLen;
			len = (int)((uint)Marshal.OffsetOf<IM_L_STREAM>("buf") + tmp_ul);

			return len;
		}


		//
		public static unsafe int retrieveImObjListReq2Stream(uint uiStreamId, RETRIEVE_IMOBJLIST_REQ* pReq, byte* buf, uint* uiBufSize)
		{
			int iErr = -1;
			byte* ptr = buf;
			uint len = *uiBufSize;

			if (null==pReq) return -1;

			if (0!=data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_start, (void*)uiStreamId, 0, &ptr, &len)) goto errLabel;

			if (0!=pReq->usMaxContactUpdateInfosPerSnd)
			{
				if (0!=data2Stream(Consts.CONST_qyDataType_short, Consts.CONST_qnmCfgId_usMaxMemsPerSnd, (void*)pReq->usMaxContactUpdateInfosPerSnd, 0, &ptr, &len)) goto errLabel;
			}
			if (0!=pReq->tLastRefreshedTime_contactList_misServ)
			{
				if (0!=data2Stream(Consts.CONST_qyDataType_l64, Consts.CONST_qnmCfgId_tLastRefreshedTime, (void*)&pReq->tLastRefreshedTime_contactList_misServ, sizeof(Int64),  &ptr,  &len  )  )  goto errLabel;
			}
			if (0!=pReq->ucbNext)
			{
				if (0 != data2Stream(Consts.CONST_qyDataType_char, Consts.CONST_qnmCfgId_ucbNext, (void*)pReq->ucbNext, 0, &ptr, &len)) goto errLabel;
			}
			if (0 != pReq->idInfo_grp_lastRefreshed.ui64Id)
			{
				if (0!=data2Stream(Consts.CONST_qyDataType_l64, Consts.CONST_qnmCfgId_idInfo_grp_lastRefreshed, (void*)&pReq->idInfo_grp_lastRefreshed.ui64Id, sizeof(UInt64),  &ptr,  &len  )  )  goto errLabel;
			}
			if (0 != pReq->idInfo_lastRefreshed.ui64Id)
			{
				if (0!=data2Stream(Consts.CONST_qyDataType_l64, Consts.CONST_qnmCfgId_idInfo_lastRefreshed, (void*)&pReq->idInfo_lastRefreshed.ui64Id, sizeof(UInt64),  &ptr,  &len  )  )  goto errLabel;
			}

			//
			if (0 != data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_null, null, 0, &ptr, &len)) goto errLabel;

			iErr = 0;
		errLabel:
			if (0==iErr)
			{
				*uiBufSize = *uiBufSize - len;
			}
			return iErr;
		}


		public static unsafe int tmpHandler_stream2RetrieveImObjListReq(void* p0, void* p1, uint uiStreamId, QY_CFGITEM_ntoh_U* pItem)
		{
			int iErr = -1;
			//  p0;
			RETRIEVE_IMOBJLIST_REQ* pReq = (RETRIEVE_IMOBJLIST_REQ*)p1;
			//  QY_CFGITEM				*	pItem		=	(  QY_CFGITEM  *  )p2;
			//  long						lVal;

			if (null==pReq) goto errLabel;

			switch (uiStreamId)
			{
				case Consts.CONST_imCommType_retrieveImGrpListReq:
				case Consts.CONST_imCommType_retrieveImGrpMemListReq:
				case Consts.CONST_imCommType_retrieveContactListReq:
				case Consts.CONST_imCommType_retrieveImObjListEndReq:
				case Consts.CONST_imCommType_retrieveWebContactListReq:
					break;
				default:
					{
						string str;
						str=string.Format("tmpHandler_stream2RetrieveImObjListReq: unknown uiStreamId: {0}", uiStreamId);
						traceLog(str);
					}
					goto errLabel;
			}

			ushort tmp_cfgId;
			//memcpy(&tmp_cfgId, &pItem->head.cfgId, sizeof(short));
			tmp_cfgId = pItem->head.cfgId;

			switch (tmp_cfgId)
			{
				case Consts.CONST_qnmCfgId_start:
					pReq->uiType = uiStreamId;
					break;
				case Consts.CONST_qnmCfgId_usMaxMemsPerSnd:
					if (0!=getFieldData_short(pItem, (short*)&pReq->usMaxContactUpdateInfosPerSnd)) goto errLabel;
					break;
				case Consts.CONST_qnmCfgId_tLastRefreshedTime:
					if (0!=getFieldData_l64(pItem, (Int64*)&pReq->tLastRefreshedTime_contactList_misServ)) goto errLabel;
					break;
				case Consts.CONST_qnmCfgId_ucbNext:
					if (0!=getFieldData_byte(pItem, (byte*)&pReq->ucbNext)) goto errLabel;
					break;
				case Consts.CONST_qnmCfgId_idInfo_grp_lastRefreshed:
					if (0!=getFieldData_l64(pItem, (Int64*)&pReq->idInfo_grp_lastRefreshed.ui64Id)) goto errLabel;
					break;
				case Consts.CONST_qnmCfgId_idInfo_lastRefreshed:
					if (0!=getFieldData_l64(pItem, (Int64*)&pReq->idInfo_lastRefreshed.ui64Id)) goto errLabel;
					break;
				default:
					break;
			}
			iErr = 0;
		errLabel:
			return iErr;
		}




		public static unsafe int retrieveImGrpListResp2Stream(uint uiStreamId, RETRIEVE_IMGRPLIST_RESP* pUpdateInfos, byte* buf, uint* uiBufSize)
		{
			int iErr = -1;
			int i = 0;
			byte* ptr = buf;
			uint len = *uiBufSize;

			if (null==pUpdateInfos) return -1;
			if (null==buf) return -1;
			//
			if (pUpdateInfos->usCnt > Consts.CONST_maxContactUpdateInfos_grp) return -1;

			if (0!=data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_start, (void*)uiStreamId, 0, &ptr, &len)) goto errLabel;

			if (0 != pUpdateInfos->idInfo_lastRefreshed.ui64Id)
			{
				if (0 != data2Stream(Consts.CONST_qyDataType_l64, Consts.CONST_qnmCfgId_idInfo_lastRefreshed, &pUpdateInfos->idInfo_lastRefreshed.ui64Id, sizeof(UInt64),  &ptr,  &len  )  )  goto errLabel;
			}

			if (0 != pUpdateInfos->ucbEnd)
			{
				if (0 != data2Stream(Consts.CONST_qyDataType_char, Consts.CONST_qnmCfgId_ucbEnd, (void*)pUpdateInfos->ucbEnd, 0, &ptr, &len)) goto errLabel;
			}
			if (0 != pUpdateInfos->usCnt)
			{
				//
				if (0 != data2Stream(Consts.CONST_qyDataType_short, Consts.CONST_qnmCfgId_usCnt, (void*)pUpdateInfos->usCnt, 0, &ptr, &len)) goto errLabel;

				//
				IM_GRP_INFO* pMems = (IM_GRP_INFO*)pUpdateInfos->buf_imGrpInfo_mems;
				for (i = 0; i < pUpdateInfos->usCnt; i++)
				{
					//  ÏÂÃæ½«Ò»¸öQY_MESSENGER_REGINFO×ª»»³ÉÁ÷
					//IM_GRP_INFO* pRegInfo = &pUpdateInfos->mems[i];
					IM_GRP_INFO* pRegInfo = &pMems[i];

					if (0 != data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_start, (void*)Consts.CONST_imCommType_mem, 0, &ptr, &len)) goto errLabel;

					if (0 != pRegInfo->idInfo.ui64Id)
					{
						if (0!=data2Stream(Consts.CONST_qyDataType_l64, Consts.CONST_qnmCfgId_messengerId, (void*)&pRegInfo->idInfo.ui64Id, sizeof(UInt64),  &ptr,  &len  )  )  goto errLabel;
			}
			if (0 != pRegInfo->name[0])
			{
				if (0 != data2Stream(Consts.CONST_qyDataType_wStr, Consts.CONST_qnmCfgId_hint, pRegInfo->name, (uint)mywcslen(pRegInfo->name), &ptr, &len)) goto errLabel;
			}

			//  2014/01/31
			if (0 != pRegInfo->usSubtype)
			{
				if (0 != data2Stream(Consts.CONST_qyDataType_short, Consts.CONST_qnmCfgId_subtype, (void*)pRegInfo->usSubtype, 0, &ptr, &len)) goto errLabel;
			}

			//  2017/07/26
			if (0 != pRegInfo->idInfo_creator.ui64Id)
			{
				if (0 != data2Stream(Consts.CONST_qyDataType_l64, Consts.CONST_qnmCfgId_idInfo_creator, (void*)&pRegInfo->idInfo_creator.ui64Id, sizeof(UInt64),  &ptr,  &len  )  )  goto errLabel;
			}

			//
			if (0 != data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_null, null, 0, &ptr, &len)) goto errLabel;
		}
	}

	 if  (0!=data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_null,  null,  0,  &ptr,  &len  )  )  goto  errLabel;
     
	 iErr  =  0;
errLabel:
	 if  (  0==iErr  )  {
		 * uiBufSize = *uiBufSize - len;
}
return iErr;	 
}

 public static unsafe int tmpHandler_stream2RetrieveImGrpListResp(void* p0, void* p1, uint uiStreamId, QY_CFGITEM_ntoh_U* pItem)
{
	int iErr = -1;
	//  p0;
	RETRIEVE_IMGRPLIST_RESP* pResp = (RETRIEVE_IMGRPLIST_RESP*)p1;
	//  QY_CFGITEM					*	pItem		=	(  QY_CFGITEM  *  )p2;

	if (null==pResp) goto errLabel;

	ushort tmp_cfgId;
			//memcpy(&tmp_cfgId, &pItem->head.cfgId, sizeof(short));
			tmp_cfgId = pItem->head.cfgId;
	switch (uiStreamId)
	{
		case Consts.CONST_imCommType_retrieveImGrpListResp:
			switch (tmp_cfgId)
			{
				case Consts.CONST_qnmCfgId_start:
					pResp->uiType = uiStreamId;
					break;
				case Consts.CONST_qnmCfgId_ucbEnd:
					if (0!=getFieldData_byte(pItem, (byte*)&pResp->ucbEnd)) goto errLabel;
					break;
				//
				case Consts.CONST_qnmCfgId_idInfo_lastRefreshed:
					if (0 != getFieldData_l64(pItem, (Int64*)&pResp->idInfo_lastRefreshed.ui64Id)) goto errLabel;
					break;
				case Consts.CONST_qnmCfgId_usCnt:
					if (0 != getFieldData_short(pItem, (short*)&pResp->usCnt)) goto errLabel;
					//
					if (pResp->usCnt > Consts.CONST_maxContactUpdateInfos_grp) goto errLabel;
					break;
				default:
					break;
			}
			break;
		case Consts.CONST_imCommType_mem:
			{
				IM_GRP_INFO* pMem = null;
				//
				if (pResp->index >= Consts.CONST_maxContactUpdateInfos_grp)
				{
					traceLogA("tmpHandler_stream2RetrieveImGrpListResp: failed"); goto errLabel;
				}
						IM_GRP_INFO* pMems = (IM_GRP_INFO*)pResp->buf_imGrpInfo_mems;
				//
				pMem = &pMems[pResp->index];
				switch (tmp_cfgId)
				{
					case Consts.CONST_qnmCfgId_messengerId:
						if (0!=getFieldData_l64(pItem, (Int64*)&pMem->idInfo.ui64Id)) goto errLabel;
						break;
					case Consts.CONST_qnmCfgId_hint:
						if (0 != getFieldData_wStr(pItem, pMem->name, Consts.CONST_maxNameLen + 1)) goto errLabel;
						break;
					case Consts.CONST_qnmCfgId_subtype:    //  2014/01/31
						if (0 != getFieldData_short(pItem, (short*)&pMem->usSubtype)) goto errLabel;
						break;
					case Consts.CONST_qnmCfgId_idInfo_creator: //  2017/07/27
						if (0 != getFieldData_l64(pItem, (Int64*)&pMem->idInfo_creator.ui64Id)) goto errLabel;
						break;
					case Consts.CONST_qnmCfgId_null:
						pResp->index++;
						break;
					default:
						break;
				}
				//
			}
			break;
		default:
			break;
	}

	iErr = 0;
errLabel:
	if (0!=iErr)
	{
		traceLogA("tmpHandler_stream2RetrieveImGrpListResp: failed");
	}
	return iErr;
}


/////////////////////

public static unsafe int retrieveImGrpMemListResp2Stream(uint uiStreamId, RETRIEVE_IMGRPMEMLIST_RESP* pUpdateInfos, byte* buf, uint* uiBufSize)
{
	int iErr = -1;
	int i = 0;
	byte* ptr = buf;
	uint len = *uiBufSize;

	if (null==pUpdateInfos) return -1;
	if (null==buf) return -1;
	//
	if (pUpdateInfos->usCnt > Consts.CONST_maxContactUpdateInfos_grpMem) return -1;

	if (0!=data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_start, (void*)uiStreamId, 0, &ptr, &len)) goto errLabel;

	if (0 != pUpdateInfos->idInfo_grp_lastRefreshed.ui64Id)
	{
		if (0 != data2Stream(Consts.CONST_qyDataType_l64, Consts.CONST_qnmCfgId_idInfo_grp_lastRefreshed, &pUpdateInfos->idInfo_grp_lastRefreshed.ui64Id, sizeof(UInt64),  &ptr,  &len  )  )  goto errLabel;
	 }
	 if (0 != pUpdateInfos->idInfo_lastRefreshed.ui64Id)
{
	if (0 != data2Stream(Consts.CONST_qyDataType_l64, Consts.CONST_qnmCfgId_idInfo_lastRefreshed, &pUpdateInfos->idInfo_lastRefreshed.ui64Id, sizeof(UInt64),  &ptr,  &len  )  )  goto errLabel;
}

if (0 != pUpdateInfos->ucbEnd)
{
	if (0 != data2Stream(Consts.CONST_qyDataType_char, Consts.CONST_qnmCfgId_ucbEnd, (void*)pUpdateInfos->ucbEnd, 0, &ptr, &len)) goto errLabel;
}
if (0 != pUpdateInfos->usCnt)
{
	//
	if (0 != data2Stream(Consts.CONST_qyDataType_short, Consts.CONST_qnmCfgId_usCnt, (void*)pUpdateInfos->usCnt, 0, &ptr, &len)) goto errLabel;

	//
	for (i = 0; i < pUpdateInfos->usCnt; i++)
	{
					//  ÏÂÃæ½«Ò»¸öQY_MESSENGER_REGINFO×ª»»³ÉÁ÷
					IM_GRP_MEM* pMems = (IM_GRP_MEM * )pUpdateInfos->buf_imGrpMem_mems;
		IM_GRP_MEM* pRegInfo = &pMems[i];

		if (0 != data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_start, (void*)Consts.CONST_imCommType_mem, 0, &ptr, &len)) goto errLabel;

		if (0 != pRegInfo->idInfo_grp.ui64Id)
		{
			if (0 != data2Stream(Consts.CONST_qyDataType_l64, Consts.CONST_qnmCfgId_idInfo_grp, (void*)&pRegInfo->idInfo_grp.ui64Id, sizeof(UInt64),  &ptr,  &len  )  )  goto errLabel;
}
if (0 != pRegInfo->idInfo_mem.ui64Id)
{
	if (0 != data2Stream(Consts.CONST_qyDataType_l64, Consts.CONST_qnmCfgId_messengerId, (void*)&pRegInfo->idInfo_mem.ui64Id, sizeof(UInt64),  &ptr,  &len  )  )  goto errLabel;
}
if (0 != pRegInfo->iRole)
{
	if (0 != data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_iRole, (void*)pRegInfo->iRole, 0, &ptr, &len)) goto errLabel;
}

if (0 != data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_null, null, 0, &ptr, &len)) goto errLabel;
		   }
	 }

	 if (0!=data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_null, null, 0, &ptr, &len)) goto errLabel;

iErr = 0;
errLabel:
if (0==iErr)
{
	*uiBufSize = *uiBufSize - len;
}
return iErr;	 
}

 public static unsafe int tmpHandler_stream2RetrieveImGrpMemListResp(void* p0, void* p1, uint uiStreamId, QY_CFGITEM_ntoh_U* pItem)
{
	int iErr = -1;
	//  p0;
	RETRIEVE_IMGRPMEMLIST_RESP* pResp = (RETRIEVE_IMGRPMEMLIST_RESP*)p1;
	//  QY_CFGITEM					*	pItem		=	(  QY_CFGITEM  *  )p2;

	if (null==pResp) goto errLabel;

	ushort tmp_cfgId;
			//memcpy(&tmp_cfgId, &pItem->head.cfgId, sizeof(short));
			tmp_cfgId = pItem->head.cfgId;

	switch (uiStreamId)
	{
		case Consts.CONST_imCommType_retrieveImGrpMemListResp:
			switch (tmp_cfgId)
			{
				case Consts.CONST_qnmCfgId_start:
					pResp->uiType = uiStreamId;
					break;
				case Consts.CONST_qnmCfgId_ucbEnd:
					if (0!=getFieldData_byte(pItem, (byte*)&pResp->ucbEnd)) goto errLabel;
					break;
				case Consts.CONST_qnmCfgId_idInfo_grp_lastRefreshed:
					if (0 != getFieldData_l64(pItem, (Int64*)&pResp->idInfo_grp_lastRefreshed.ui64Id)) goto errLabel;
					break;
				case Consts.CONST_qnmCfgId_idInfo_lastRefreshed:
					if (0 != getFieldData_l64(pItem, (Int64*)&pResp->idInfo_lastRefreshed.ui64Id)) goto errLabel;
					break;
				case Consts.CONST_qnmCfgId_usCnt:
					if (0 != getFieldData_short(pItem, (short*)&pResp->usCnt)) goto errLabel;
					//
					if (pResp->usCnt > Consts.CONST_maxContactUpdateInfos_grpMem) goto errLabel;
					break;
				default:
					break;
			}
			break;
		case Consts.CONST_imCommType_mem:
			{
				IM_GRP_MEM* pMem = null;
				//
				if (pResp->index >= Consts.CONST_maxContactUpdateInfos_grpMem)
				{
					traceLogA("tmpHandler_stream2RetrieveImGrpListResp: failed"); goto errLabel;
				}
						//
						IM_GRP_MEM* pMems = (IM_GRP_MEM * )pResp->buf_imGrpMem_mems;
				pMem = &pMems[pResp->index];
				switch (tmp_cfgId)
				{
					case Consts.CONST_qnmCfgId_idInfo_grp:
						if (0!=getFieldData_l64(pItem, (Int64*)&pMem->idInfo_grp.ui64Id)) goto errLabel;
						break;
					case Consts.CONST_qnmCfgId_messengerId:
						if (0 != getFieldData_l64(pItem, (Int64*)&pMem->idInfo_mem.ui64Id)) goto errLabel;
						break;
					case Consts.CONST_qnmCfgId_iRole:
						if (0 != getFieldData_long(pItem, (int*)&pMem->iRole)) goto errLabel;
						break;
					case Consts.CONST_qnmCfgId_null:
						pResp->index++;
						break;
					default:
						break;
				}
				//
			}
			break;
		default:
			break;
	}

	iErr = 0;
errLabel:
	if (0!=iErr)
	{
		traceLogA("tmpHandler_stream2RetrieveImGrpMemListResp: failed");
	}
	return iErr;
}



public static unsafe int retrieveContactListResp2Stream(uint uiStreamId, RETRIEVE_CONTACTLIST_RESP* pUpdateInfos, byte* buf, uint* uiBufSize)
{
	int iErr = -1;
	int i = 0;
	byte* ptr = buf;
	uint len = *uiBufSize;
	int j;

	if (null==pUpdateInfos) return -1;
	if (null==buf) return -1;
	//
	if (pUpdateInfos->usCnt > Consts.CONST_maxContactUpdateInfos_contact) return -1;

	if (0!=data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_start, (void*)uiStreamId, 0, &ptr, &len)) goto errLabel;

	if (0 != pUpdateInfos->idInfo_lastRefreshed.ui64Id)
	{
		if (0 != data2Stream(Consts.CONST_qyDataType_l64, Consts.CONST_qnmCfgId_idInfo_lastRefreshed, &pUpdateInfos->idInfo_lastRefreshed.ui64Id, sizeof(UInt64),  &ptr,  &len  )  )  goto errLabel;
	 }		 	 

	 if (0 != pUpdateInfos->ucbEnd)
{
	if (0 != data2Stream(Consts.CONST_qyDataType_char, Consts.CONST_qnmCfgId_ucbEnd, (void*)pUpdateInfos->ucbEnd, 0, &ptr, &len)) goto errLabel;
}
if (0 != pUpdateInfos->usCnt)
{
	//
	if (0 != data2Stream(Consts.CONST_qyDataType_short, Consts.CONST_qnmCfgId_usCnt, (void*)pUpdateInfos->usCnt, 0, &ptr, &len)) goto errLabel;
	//
	for (i = 0; i < pUpdateInfos->usCnt; i++)
	{
					//  ÏÂÃæ½«Ò»¸öQY_MESSENGER_REGINFO×ª»»³ÉÁ÷
					RETRIEVE_contact_mem* pMems = (RETRIEVE_contact_mem*)pUpdateInfos->buf_retrieveContactMem_mems;
		RETRIEVE_contact_mem* pMem = &pMems[i];
		QY_MESSENGER_REGINFO* pRegInfo = &pMem->regInfo;

		if (0 != data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_start, (void*)Consts.CONST_imCommType_mem, 0, &ptr, &len)) goto errLabel;

		if (0 != pRegInfo->addr.uiObjType && 0!=data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_uiObjType, (void*)pRegInfo->addr.uiObjType, 0, &ptr, &len)) goto errLabel;    //  2008/01/31
		if (0 != pRegInfo->addr.idInfo.ui64Id && 0 != data2Stream(Consts.CONST_qyDataType_l64, Consts.CONST_qnmCfgId_messengerId, (void*)&pRegInfo->addr.idInfo.ui64Id, sizeof(UInt64),  &ptr,  &len  )  )  goto errLabel;
	//
	if (0 != pMem->iRole)
	{  //  2017/08/14
		if (0 != data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_iRole, (void*)pMem->iRole, 0, &ptr, &len)) goto errLabel;
	}
	//
	if (0 != pRegInfo->addr.uiDevType && 0!=data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_uiDevType_from, (void*)pRegInfo->addr.uiDevType, 0, &ptr, &len)) goto errLabel;
	//if (0 != pRegInfo->addr.wDevIdStr[0] && 0 != data2Stream(Consts.CONST_qyDataType_wStr, Consts.CONST_qnmCfgId_wDevIdStr_from, pRegInfo->addr.wDevIdStr, lstrlen(pRegInfo->addr.wDevIdStr), &ptr, &len)) goto errLabel;   //  2008/01/31

					//
#if false
					for (j = 0; j < mycountof(pRegInfo->uiFieldIds); j++)
	{
		if (!pRegInfo->u.cols[j][0]) continue;
		if (data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_uiFieldId, (void*)pRegInfo->uiFieldIds[j], 0, &ptr, &len)) goto errLabel;
		if (data2Stream(Consts.CONST_qyDataType_wStr, Consts.CONST_qnmCfgId_hint, pRegInfo->u.cols[j], lstrlen(pRegInfo->u.cols[j]), &ptr, &len)) goto errLabel;
	}
#endif

	if (0 != data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_null, null, 0, &ptr, &len)) goto errLabel;
}
	 }

	 if (0!=data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_null, null, 0, &ptr, &len)) goto errLabel;

iErr = 0;
errLabel:
if (0==iErr)
{
	*uiBufSize = *uiBufSize - len;
}
return iErr;	 
}


 public static unsafe int tmpHandler_stream2RetrieveContactListResp(void* p0, void* p1, uint uiStreamId, QY_CFGITEM_ntoh_U* pItem)
{
	int iErr = -1;
	//  p0;
	RETRIEVE_CONTACTLIST_RESP* pResp = (RETRIEVE_CONTACTLIST_RESP*)p1;
	//  QY_CFGITEM					*	pItem		=	(  QY_CFGITEM  *  )p2;
	int lVal;

	if (null==pResp) goto errLabel;

	ushort tmp_cfgId;
			//memcpy(&tmp_cfgId, &pItem->head.cfgId, sizeof(short));
			tmp_cfgId = pItem->head.cfgId;

	switch (uiStreamId)
	{
		case Consts.CONST_imCommType_retrieveContactListResp:
			switch (tmp_cfgId)
			{
				case Consts.CONST_qnmCfgId_start:
					pResp->uiType = uiStreamId;
					break;
				case Consts.CONST_qnmCfgId_ucbEnd:
					if (0!=getFieldData_byte(pItem, (byte*)&pResp->ucbEnd)) goto errLabel;
					break;
				//
				case Consts.CONST_qnmCfgId_idInfo_lastRefreshed:
					if (0!=getFieldData_l64(pItem, (Int64*)&pResp->idInfo_lastRefreshed.ui64Id)) goto errLabel;
					break;
				case Consts.CONST_qnmCfgId_usCnt:
					if (0 != getFieldData_short(pItem, (short*)&pResp->usCnt)) goto errLabel;
					//
					if (pResp->usCnt > Consts.CONST_maxContactUpdateInfos_contact) goto errLabel;
					break;
				default:
					break;
			}
			break;
		case Consts.CONST_imCommType_mem:
			{
				RETRIEVE_contact_mem* pMem = null;
				//
				if (pResp->index >= Consts.CONST_maxContactUpdateInfos_contact || pResp->iFiledIndex >= Consts.CONST_qnmMaxRegFields)
				{
					traceLogA("tmpHandler_stream2RetrieveContactListResp: failed");
					goto errLabel;
				}
						RETRIEVE_contact_mem* pMems = (RETRIEVE_contact_mem*)pResp->buf_retrieveContactMem_mems;
				//
				pMem = &pMems[pResp->index];
				switch (tmp_cfgId)
				{
					case Consts.CONST_qnmCfgId_uiObjType:
						if (0 != getFieldData_long(pItem, (int*)&pMem->regInfo.addr.uiObjType)) goto errLabel;
						break;
					case Consts.CONST_qnmCfgId_messengerId:
						if (0 != getFieldData_l64(pItem, (Int64*)&pMem->regInfo.addr.idInfo.ui64Id)) goto errLabel;
						break;
					case Consts.CONST_qnmCfgId_iRole:  //  2017/08.14
						if (0 != getFieldData_long(pItem, (int*)&pMem->iRole)) goto errLabel;
						break;
					case Consts.CONST_qnmCfgId_uiDevType_from:
						if (0 != getFieldData_long(pItem, (int*)&pMem->regInfo.addr.uiDevType)) goto errLabel;
						break;
								/*
					case Consts.CONST_qnmCfgId_wDevIdStr_from:
						if (getFieldData_wStr(pItem, pMem->regInfo.addr.wDevIdStr, mycountof(pMem->regInfo.addr.wDevIdStr))) goto errLabel;
						break;
								*/
					case Consts.CONST_qnmCfgId_uiFieldId:
						if (0 != getFieldData_long(pItem, &lVal)) goto errLabel;
						pMem->regInfo.uiFieldIds[pResp->iFiledIndex] = (uint)lVal;
						break;
					case Consts.CONST_qnmCfgId_hint:
								{
									//if (0 != getFieldData_wStr(pItem, pMem->regInfo.u.cols[pResp->iFiledIndex], mycountof(pMem->regInfo.u.cols[pResp->iFiledIndex]))) goto errLabel;
									if (0 != getFieldData_wStr(pItem, pMem->regInfo.tmp_col, Consts.CONST_maxNameLen+1)) goto errLabel;
									switch(pMem->regInfo.uiFieldIds[pResp->iFiledIndex])
                                    {
										case Consts.CONST_fieldId_dw:
											mytcsncpy(pMem->regInfo.dw, new string(pMem->regInfo.tmp_col), Consts.CONST_maxNameLen + 1);
											break;
										case Consts.CONST_fieldId_bm:
											 mytcsncpy(pMem->regInfo.bm, new string(pMem->regInfo.tmp_col), Consts.CONST_maxNameLen + 1);
											break;
										case Consts.CONST_fieldId_syr:
											mytcsncpy(pMem->regInfo.syr, new string(pMem->regInfo.tmp_col), Consts.CONST_maxNameLen + 1);
											break;
										default:
											break;

                                    }
								}
						pResp->iFiledIndex++;
						break;
					case Consts.CONST_qnmCfgId_null:
						pResp->index++;
						pResp->iFiledIndex = 0;
						break;
					default:
						break;
				}
				//
			}
			break;
		default:
			break;
	}

	iErr = 0;
errLabel:
	if (iErr!=0)
	{
		traceLogA("tmpHandler_stream2RetrieveContactListResp: failed");
	}
	return iErr;
}

		////////////////////

		/*
						unsigned  int										uiType;
						//
						__int64											tLastRefreshedTime_contactList_misServ;		//  ·¢ËÍ¸ø¿Í»§¶ËÈÃÖªµÀÊÇ´ÓÊ²Ã´Ê±¼ä¿ªÊ¼Ë¢ÐÂµÄ
						*/

	public static unsafe	int retrieveImObjListEndResp2Stream(uint uiStreamId, RETRIEVE_IMOBJLISTEND_RESP* pResp, byte* buf, uint* uiBufSize)
{
	int iErr = -1;
	int i = 0;
	byte* ptr = buf;
	uint len = *uiBufSize;

	if (null==pResp) return -1;
	if (null==buf) return -1;

	if (0!=data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_start, (void*)uiStreamId, 0, &ptr, &len)) goto errLabel;

	if (0 != pResp->tLastRefreshedTime_contactList_misServ)
	{
		if (0 != data2Stream(Consts.CONST_qyDataType_l64, Consts.CONST_qnmCfgId_tLastRefreshedTime, (void*)&pResp->tLastRefreshedTime_contactList_misServ, sizeof(Int64),  &ptr,  &len  )  )  goto errLabel;
	 }
	
	 if (0!=data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_null, null, 0, &ptr, &len)) goto errLabel;

iErr = 0;
errLabel:
if (0==iErr)
{
	*uiBufSize = *uiBufSize - len;
}
return iErr;	 
}



 public static unsafe int tmpHandler_stream2RetrieveImObjListEndResp(void* p0, void* p1, uint uiStreamId, QY_CFGITEM_ntoh_U* pItem)
{
	int iErr = -1;
	//  p0;
	RETRIEVE_IMOBJLISTEND_RESP* pResp = (RETRIEVE_IMOBJLISTEND_RESP*)p1;
	//  QY_CFGITEM							*	pItem		=	(  QY_CFGITEM  *  )p2;
	//  long						lVal;

	if (null==pResp) goto errLabel;

	if (uiStreamId != Consts.CONST_imCommType_retrieveImObjListEndResp) goto errLabel;

	ushort tmp_cfgId;
			//memcpy(&tmp_cfgId, &pItem->head.cfgId, sizeof(short));
			tmp_cfgId = pItem->head.cfgId;

	switch (tmp_cfgId)
	{
		case Consts.CONST_qnmCfgId_start:
			pResp->uiType = uiStreamId;
			break;
		case Consts.CONST_qnmCfgId_tLastRefreshedTime:
			if (0!=getFieldData_l64(pItem, &pResp->tLastRefreshedTime_contactList_misServ)) goto errLabel;
			break;
		default:
			break;
	}
	iErr = 0;
errLabel:
	return iErr;
}




public static unsafe 		int qisGetCfgsReq2Stream(uint uiStreamId, QIS_getCfgs_req* pReq, byte* buf, uint* uiBufSize)
		{
			int iErr = -1;
			int i = 0;
			byte* ptr = buf;
			uint len = *uiBufSize;

			if (null==pReq) return -1;
			if (null==buf) return -1;

			if (0!=data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_start, (void*)uiStreamId, 0, &ptr, &len)) goto errLabel;

			if (0 != pReq->ucbResp)
			{
				if (0 != data2Stream(Consts.CONST_qyDataType_char, Consts.CONST_qnmCfgId_ucbResp, (void*)pReq->ucbResp, 0, &ptr, &len)) goto errLabel;
			}

			if (0 != pReq->uiSizePerSnd_media)
			{
				if (0 != data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_uiSizePerSnd, (void*)pReq->uiSizePerSnd_media, 0, &ptr, &len)) goto errLabel;
			}

			if (0 != data2Stream(Consts.CONST_qyDataType_short, Consts.CONST_qnmCfgId_usIntervalInS_refreshRecentFriends, (void*)pReq->intervalParams.usIntervalInS_refreshRecentFriends, 0, &ptr, &len)) goto errLabel;
			if (0 != data2Stream(Consts.CONST_qyDataType_short, Consts.CONST_qnmCfgId_usIntervalInS_refreshContactList, (void*)pReq->intervalParams.usIntervalInS_refreshContactList, 0, &ptr, &len)) goto errLabel;

			//  2015/07/28

			//
			if (0 != data2Stream(Consts.CONST_qyDataType_long, Consts.CONST_qnmCfgId_null, null, 0, &ptr, &len)) goto errLabel;

			iErr = 0;
		errLabel:
			if (0==iErr)
			{
				*uiBufSize = *uiBufSize - len;
			}
			return iErr;

		}


		public static unsafe int tmpHandler_stream2QisGetCfgsReq(void* p0, void* p1, uint uiStreamId, QY_CFGITEM_ntoh_U* pItem)
		{
			int iErr = -1;
			//  p0;
			QIS_getCfgs_req* pContent = (QIS_getCfgs_req*)p1;
			//  QY_CFGITEM				*	pItem		=	(  QY_CFGITEM  *  )p2;
			//  long						lVal;

			if (null==pContent) goto errLabel;

			if (uiStreamId != Consts.CONST_imCommType_getCfgsReq) goto errLabel;

			ushort tmp_cfgId;
			tmp_cfgId=pItem->head.cfgId;
			switch (tmp_cfgId)
			{
				case Consts.CONST_qnmCfgId_start:
					pContent->uiType = uiStreamId;
					break;
				case Consts.CONST_qnmCfgId_ucbResp:
					if (0!=getFieldData_byte(pItem, (byte*)&pContent->ucbResp)) goto errLabel;
					break;
				case Consts.CONST_qnmCfgId_uiSizePerSnd:
					if (0 != getFieldData_long(pItem, (int*)&pContent->uiSizePerSnd_media)) goto errLabel;
					break;
				case Consts.CONST_qnmCfgId_usIntervalInS_refreshRecentFriends:
					if (0 != getFieldData_short(pItem, (short*)&pContent->intervalParams.usIntervalInS_refreshRecentFriends)) goto errLabel;
					break;
				case Consts.CONST_qnmCfgId_usIntervalInS_refreshContactList:
					if (0 != getFieldData_short(pItem, (short*)&pContent->intervalParams.usIntervalInS_refreshContactList)) goto errLabel;
					break;
				default:
					break;
			}
			iErr = 0;
		errLabel:
			return iErr;
		}



		public static unsafe int qyhtonImContentU(int lhClientVer, IM_CONTENTU* p)
		{
			int len = -1;

			switch (p->uiType)
			{
				case Consts.CONST_imCommType_simpleResp:
					return qyhtonImSimpleResp(lhClientVer, &p->simpleResp);
				//
#if false
			case  CONST_imCommType_streamContent:
				  return  qyhtonImStreamContent(  lhClientVer,  &p->stream  );
#endif

				case Consts.CONST_imCommType_lStream:
					return qyhtonImLStream(lhClientVer, &p->lStream);

				case Consts.CONST_imCommType_htmlContent:
					traceLogA("qyhtonImMsgContentU failed, htmlContent");
					break;
				default:
					{
						string str;
						str = string.Format("qyhtonImMsgContentU failed, unknown uiType {0}", p->uiType);
						traceLog(str);
					}
					break;
			}

			//  errLabel:
			return len;
		}

		public static unsafe int qyntohImContentU(int lhClientVer, byte* src, IM_CONTENTU_nh* p)
		{
			int len = -1;
			uint uiType = 0;

			//  uiType  =  qyntohl(  p->uiType  );
			mymemcpy((IntPtr)(byte*)&uiType, (IntPtr)src, sizeof(uint));
			uiType=qyntohi(uiType);

			switch (uiType)
			{
				case Consts.CONST_imCommType_simpleResp:
					mymemcpy((IntPtr)(byte*)&p->simpleResp, (IntPtr)src, (uint)sizeof(IM_SIMPLE_RESP)  );
					return qyntohImSimpleResp(lhClientVer, &p->simpleResp);
				//
#if false
			case  CONST_imCommType_streamContent:
				  //  return  qyntohImStreamContent(  lhClientVer,  &p->stream  );					//  2010/07/10. 这里应该设计一个专门的IM_CONTENTU_ntoh
				  return  qyntohImStreamContent(  lhClientVer,  src,  &p->stream  );				//  
#endif

				case Consts.CONST_imCommType_htmlContent:
					traceLogA("qyntohImMsgContentU failed, htmlContent");
					break;
				case Consts.CONST_imCommType_lStream:
					//  return  qyntohImLStream(  lhClientVer,  &p->lStream  );					//  2010/07/10. 这里应该设计一个专门的IM_CONTENTU_ntoh
					return qyntohImLStream(lhClientVer, src, &p->lStream);                  //  
				default:
					{
						string str;
						str = string.Format("qyntohImMsgContentU failed, unprocessed type {0}", uiType);
						traceLog(str);
					}
					break;
			}

			//  errLabel:
			return len;
		}






	}
}

	

	



